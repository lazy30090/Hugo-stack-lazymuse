---
author: "lazy"
title: "Computer Organization Note Part II"
date: "2025-10-10"
description: "计组第1章笔记"
tags:
  - "Computer Organization"
categories:
  - "UESTC"
---

# 《计算机组成原理》：数据的表示、运算和校验

## 1. 进位计数制（Number Systems）

### 概念

- **基数（radix）**：每位允许的记数符号个数。例如十进制基数 10（0–9）、二进制基数 2（0–1）、八进制 8、十六进制 16（0–F）。
- **权值（weight）**：数位 i 的权值为 `base^i`。例如十进制中 256.7 = 2×10² + 5×10¹ + 6×10⁰ + 7×10⁻¹。

### 各进制常见示例

- 二进制：`(101.1)_2 = 1×2² + 0×2¹ + 1×2⁰ + 1×2⁻¹ = 5.5`
- 八进制：`(12.4)_8 = 1×8¹ + 2×8⁰ + 4×8⁻¹ = 10.5`
- 十六进制：`(3A6)_16 = 3×16² + 10×16¹ + 6 = 934`

### 二进制的运算规则（关键）

- 加法（单位）：0+0=0；0+1=1；1+1=10（产生进位）
- 减法、乘法、除法同理（见 PPT 示例）
- 二进制与十进制互换：
  - 十进制整数→二进制：反复除 2 取余（低位到高位）。
  - 十进制小数→二进制小数：反复乘 2 取整数部分（直到小数为 0 或达到精度）。
  - 二进制→十进制：按权展开求和。

### 八/十六进制与二进制转换技巧

- 八进制：每 3 位二进制为一组（从小数点向两侧分组），例如 `(1011101.0110101)_2 = (135.324)_8`。
- 十六进制：每 4 位二进制为一组，例如上例也可得到 `(5D.6A)_16`。

------

## 2. 带符号数的表示（符号与机器数）

在计算机中需要把“正/负”变成机器可计算的二进制码，常见三种表示方法（都以最高位为符号位，0 表示正，1 表示负）：

### 2.1 原码（Sign-magnitude）

- 编码规则：最高位为符号位，其余位为数值位的原值不变。
- 缺陷：存在 **+0** 和 **-0** 两种表示，减法运算复杂（需比较大小再决定符号）。

例（8 位）：

- +127 原码 = `0 1111111`
- −127 原码 = `1 1111111`
- +0 = `0 0000000`，−0 = `1 0000000`

### 2.2 反码（Ones' complement）

- 正数：反码 = 原码（不变）
- 负数：反码 = 对原码的符号位不变，数值位按位取反（1↔0）
- 缺点：仍存在 **+0** 和 **-0**（`0 0000000` 与 `1 1111111`）

例（8 位）：真值 −105

- 原码 `1 1101001` → 反码 `1 0010110`

### 2.3 补码（Two's complement） —— 现代计算机标准

- 正数：补码 = 原码（不变）
- 负数：补码 = 反码 + 1（对原码按位取反后最低位加 1）
- 优点：0 只有一种表示（`0...0`），加减法能统一为加法（符号位参与运算），硬件实现更简单；还能表示一个额外的最小负数（例如 8 位：−128 可表示）。
- 例（8 位）：补码表示范围 `-128 .. +127`。
   +127 补码 = `0 1111111`，−128 补码 = `1 0000000`

#### 常见操作（补码与原码转换）

- 已知原码求补码（负数）：按位取反后末位 +1。
- 已知补码求原码：对补码连同符号位一起“变反、末位加 1”（即对负数做再次求补得到原码）。
- 求 `[-X]` 的补码：把 `X` 的补码连同符号位一起取反然后末位 +1（即补码取负的直接变换）。

------

## 3. 定点数与浮点数（Fixed-point & Floating-point）

### 3.1 定点数

- **定义**：程序中约定小数点固定在某一位置（比如全部数的小数点在同一位置）。
- 有三类：
  1. 带符号定点小数：小数点固定在符号位之后；字长 `n+1` 时，补码表示范围为 `-1 .. 1 - 2^-n`，分辨率 `2^-n`。
  2. 带符号定点整数：小数点固定在最低数值位之后；补码范围 `-2^n .. 2^n -1`，分辨率 1。
  3. 无符号定点整数：范围 `0 .. 2^(n+1)-1`。
- 注意：定点数的小数点位置是**约定**，并不需要硬件单独表示。

### 3.2 浮点数（浮点表示法）

- **基本形式**：`N = M × R^E`（R 通常为 2），其中：
  - `M`（尾数，mantissa/significand）：带符号的定点小数（规定规格化后范围，使表示唯一）。
  - `E`（阶码，exponent）：带符号定点整数，常采用 **移码（bias）** 表示（如 IEEE754）。
  - `S`（符号位）：表示正负。
- **移码（Bias）**：对定点整数 `x` 的移码表示为 `x + 2^(n-1)`（使得阶码表现为无符号偏移，便于比较大小与排序）。
- **规格化（Normalization）**：为保证表示唯一，尾数 M 要规格化（例如二进制浮点规定 `1/2 ≤ |M| < 1` 或 `1 ≤ |M| < 2`，具体依格式而定）。规格化使最高有效位固定（通常为 1），提高精度利用率。

### IEEE 754 简明

- **32 位单精度**（single precision）格式：
  - S（1 位）| E（8 位，移码偏移 127）| M（23 位，尾数的纯小数部分，真值为 `1.M` 对于正规化数）
  - 真值：`F = (-1)^S × 1.M × 2^(E - 127)`（当 E 非全 0/全 1 并为正规化数）
- 特殊情况：
  - `E = 0` 且 `M = 0` → 表示 ±0
  - `E = 0` 且 `M ≠ 0` → 次正规数（subnormal）
  - `E = 255` 且 `M = 0` → ±∞
  - `E = 255` 且 `M ≠ 0` → NaN
- **精度**：
  - 单精度尾数 23 位 → 相对精度约 `2^-23`（加上隐含的 1，则有效精度 24 位）。
- **示例（PPT）**：把 `20.59375` 转为 IEEE754 单精度：
  1. 十进制 → 二进制：`20.59375 = 10100.10011`
  2. 规格化：`1.010010011 × 2^4`（e = 4）
  3. 阶码加偏移：`E = 4 + 127 = 131 = 10000011_b`
  4. 尾数 M = `010010011000...`（补齐 23 位）
  5. 最终二进制码：`0 10000011 01001001100000000000000` → 十六进制 `41A4C000`。（详见 PPT 步骤）1.1 数据的表示、运算和校验

------

## 4. 字符编码（ASCII）

- **ASCII**：美国标准信息交换码，使用 7 位二进制，能表示 128 个字符（包括 33 个控制字符和 95 个可打印字符）。
- 常用区间：
  - 数字 `0-9` 的十六进制代码为 `30h - 39h`
  - 大写字母 `A-Z`：`41h - 5Ah`
  - 小写字母 `a-z`：`61h - 7Ah`
- 中国还有国家标准编码（如 GB），但 ASCII 在基础英文文本与控制字符上通用。1.1 数据的表示、运算和校验

------

## 5. 定点加减运算（使用补码）

### 5.1 原理

- 使用补码表示的数（包括符号位）直接相加即可：
   `(X + Y)_补 = X_补 + Y_补`
   `(X - Y)_补 = X_补 + (-Y)_补`（把 Y 取补后相加）
- 全过程以 `2^n` 为模（即超出位宽的高位丢弃，等价于模运算）。

### 5.2 示例（逐步）

- 例 1：`X=3, Y=2`（假设 5-bit 显示为例）
  - X_补 = `0 0011`，Y_补 = `0 0010` → 相加 = `0 0101`（+5，无溢出）
- 例 2：`X=-3, Y=-2`
  - X_补 = `1 1101`（-3），Y_补 = `1 1110`（-2） → 相加得到 `1 1011`（-5 的补码）

### 5.3 注意：`变补` 与 补码 的区别（考点）

- **变补**：把某数连同符号位一起取反，末位加 1 —— 通常用于“对补码求负”或“由补码求相反数”的操作。
- **补码表示**：用于直接表示数值（正数的补码同原码，负数按反码+1）。

------

## 6. 溢出判断（Overflow Detection）

当用补码做加减时，结果可能超出机器所能表示的范围——称为溢出。PPT 给出三种硬件判断逻辑（实际任意一种都可实现）：

### 常用规则（直观）

- **加法溢出**：当两个同符号数相加，结果与操作数符号不同，则发生溢出。
  - 例如：两个正数相加却得到负数（正溢）；两个负数相加却得到正数（负溢）。
- **硬件实现方法**：
  1. **基于操作数和结果符号位**：`overflow = (SA & SB & ~SF) | (~SA & ~SB & SF)`（简化含义：若 SA == SB 且 SF != SA → 溢出）。
  2. **基于最高位进位与符号位进位比较**：`overflow = Cf ⊕ C`，其中 `C` 是尾数最高位的进位，`Cf` 是符号位的进位（PPT 术语）。
  3. **双符号位比较（Sf1 ⊕ Sf2）**：使用不同阶段的符号位判断溢出（在硬件设计中有实现方式）。

### 示例（PPT 的示例）

- `10 + 7` 在某较小位宽会发生正溢（示例中展示了进位与符号关系）。
- 综上，**最简单记忆法**：加法时若两个操作数符号相同而结果符号不同，则溢出。

------

## 7. 移位运算（Shifts）

移位是位级操作，可以是逻辑移位、算术移位或循环移位。

### 7.1 逻辑移位（Logical shift）

- 左移：在右端补 0，左移相当于乘以 2^n（若无溢出）。
- 右移：在左端补 0（用于无符号数），相当于无符号除以 2^n（舍去低位）。

### 7.2 算术移位（Arithmetic shift）

- 保持符号位不变（最高位保持原符号值），用于带符号整数（补码）右移，相当于算术除以 2（向零或向 -∞ 取整取决实现）。
- 左移与逻辑左移相同（在多数实现中空位补 0，可能产生溢出）。

### 7.3 循环移位（Rotate）

- 左/右移出位从另一端回填（常用于加密与循环缓冲）。

### PPT 中的要点（双符号位）

- 在一些原码乘法算法里，寄存器使用双符号位（第一个符号位保持原符号，第二符号位用于移位进入尾数最高位），移位规则中空位如何补 0/1 要特别注意，尤其是负数右移需补 1。

------

## 8. 舍入与截断（Rounding）

常用舍入策略（PPT 提到两种）：

1. **“0 舍 1 入”**（即遇到被丢弃位为 0，则舍弃；为 1，则向上加 1）：类似“向最近偶数/四舍五入”的简化版本。
2. **末位恒置 1**：不管被截断位如何，保留位的最低位置 1（一种保守策略，保证不上溢出但不是常用）。

**注意**：浮点运算中通常使用更复杂且规范的舍入（例如 IEEE754 的 round-to-nearest-even 等）；在定点截断时应明确采用的舍入策略以保证一致性。

------

## 9. 定点乘法（Fixed-point Multiplication）

PPT 讲解了原码一位乘法、补码一位乘法（比较法/校正法）等。

### 9.1 原码一位乘法（逐位累加移位）

- 基本思想：把乘数每一位乘以被乘数（形成部分积），把这些部分积按位移位并累加得到乘积（类似小学校算）。
- **寄存器分配（常见实现）**：
  - `A`：部分积累加和（含两位符号位）
  - `B`：被乘数的绝对值（保持不变）
  - `C`：乘数（最低位用于判断），同时存放乘积低位
- **操作**（对尾数位逐位执行）：
  - 若 `C_n = 1`：`A = A + B`，然后右移（A 的最低位移入 C 的最高位）
  - 若 `C_n = 0`：`A = A + 0`，右移
- 最后加符号位：结果符号 `S_P = S_X ⊕ S_Y`（X 与 Y 为被乘数与乘数符号）
- **示例**（PPT）：
  - `0.1101 × 0.1011`（均为正，二进制小数），手工步骤列出了部分积与累加，最终乘积为 `0.10001111`（十进制 ≈ 0.55859375）。

### 9.2 补码一位乘法（比较法）

- **校正法**：
  - 若乘数 `Y` 为正，则可按原码乘法（不需校正）。
  - 若乘数为负，需对结果做校正（加或减被乘数补码）。
- **比较法（更常用）**：
  - 用乘数的相邻两位（`Y_n` 与 `Y_{n+1}`）比较决定操作：
    - `00` 或 `11` → `A = A / 2`（不加）
    - `01` → `A = (A + X) / 2`
    - `10` → `A = (A - X) / 2`
  - 该方法减少了每一步的加减次数（属于 Booth 算法的简化思想的一类）。
- **寄存器与判定位**：
  - C 寄存器末位拼接一个附加位 `Y_{n+1}`（初始为 0），每步检查 `Y_n, Y_{n+1}`。
- **示例（PPT）**：
  - `X = -0.1101, Y = -0.1011`（补码表示），通过比较法逐步进行了 `A` 的更新，最终得到 `(XY)_补`（中间有修正步骤），示例中列出每一步的 `A` 与 `C` 内容，便于对照实现。

### 9.3 实际实现要点

- 对补码乘法，寄存器中 `B`（被乘数）通常保留补码形式（或其负值也预先计算）以便需要时加减。
- 结果位数通常为两倍尾数位（需预先分配足够寄存器位）。
- 注意符号位处理（单符号位或双符号位实现的差别），右移时如何填充符号位是关键易错处（参见 PPT 的“易出错处”）。

------

## 10. 本章小结（要点回顾）

1. **掌握进制间转换**（尤其二/八/十/十六之间的转换技巧与分组规则）。
2. **带符号数的三种表示**：原码、反码、补码 —— 理解补码优势并熟练做补码运算与变换。
3. **定点与浮点表示**：理解定点表示的约定、小数点位置含义；重点掌握 IEEE754 单精度格式（S/E/M 的位含义、偏移量、特殊值）。
4. **定点加减乘运算实现**：补码加法统一处理、溢出判断（符号位规则与进位比对）、移位规则、截断与舍入方法、定点乘法的寄存器算法（原码乘法、补码比较法）。1.1 数据的表示、运算和校验

------

## 11. 例题练习（含答案与步骤）

### 练习 1 — 进制转换

1. 将 `(369)_10` 转换为八进制和十六进制。
   - 解：`369 ÷ 8` 得商 46 余 1 → 46 ÷ 8 商 5 余 6 → 5 ÷ 8 商 0 余 5 → 八进制 `561`。
      十六进制：`369 = 1×16² + 7×16 + 1` → `(171)_16`。
      （与 PPT 示例一致）1.1 数据的表示、运算和校验

### 练习 2 — 补码运算与溢出

1. 假设用 8 位补码表示，计算 `100 + 50`（十进制），判断是否溢出。
   - 100 的 8 位补码 `01100100`，50 的 8 位补码 `00110010`，相加得 `10010110`（最高位 1 表示负），但两操作数均为正而结果为负 → **发生溢出**（结果模 256 后表示为 -106，但对有符号数这为溢出）。

### 练习 3 — IEEE754 转换

1. 将 `-6.25` 转为 IEEE754 单精度二进制表示。
   - 6.25 = `110.01_b` = `1.1001 × 2^2` → exponent = `2 + 127 = 129 = 10000001_b`，mantissa = `1001000...`（后面补零）。符号 S = 1。
   - 最终：`1 10000001 10010000000000000000000` → 十六进制可自行分组转换。

### 练习 4 — 定点乘法（逐步）

1. 计算 `0.1101 × 0.1011`（二进制小数，结果保留 8 位），手工按原码乘法步骤：
   - 参见 PPT 的手工乘法展示，最终 `0.10001111`（十进制 ≈ 0.55859375）。（已在章节中逐位解释）1.1 数据的表示、运算和校验

------

## 12. 常见易错点与考试/上机提示

- **符号位与补码概念混淆**：牢记“正数的补码 = 原码”，只有负数需要按位取反加 1。
- **0 的多重表示**：原码/反码存在 +0 / −0；补码只有单一 0。
- **溢出判断**：不要只看最高位进位，使用“两个操作数同符号且结果符号不同”更直观；硬件可以用 `Cf ⊕ C` 或 `Sf1 ⊕ Sf2`。
- **移位时填充规则**：算术右移需补符号位（符号扩展）；逻辑右移补 0。
- **浮点角标偏移（bias）**：记住单精度偏移是 127（即 E_stored = E_true + 127）。
- **浮点特殊值**：E 全 0（次正规或 0），E 全 1（±∞ 或 NaN 与 M 非零）。
