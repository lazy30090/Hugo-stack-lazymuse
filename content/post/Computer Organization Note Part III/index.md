---
author: "lazy"
title: "Computer Organization Note Part III"
date: "2025-10-11"
description: "卡诺图"
tags:
  - "Computer Organization"
categories:
  - "UESTC"
---

# 《计算机组成原理》：卡诺图

概念回顾（为什么用卡诺图）

- 卡诺图是一种以图形方式表示 n 变量逻辑函数最小项（minterm）并进行化简的方法。
- 通过把逻辑上“相邻”的最小项在几何位置上也安排相邻，可以直观地找到可以合并的项（消去变量），从而得到更简的与-或（积之和）形式。
- 目标：用尽可能少、尽可能大的“卡诺圈”覆盖所有值为 1 的小格，得到最简或接近最简的表达式（最小项数量少、每项变量数少、并考虑成本与实现）。

------

## 基本规则（必须完全掌握）

1. **格子与编号**
   - n 变量共有 `2^n` 个最小项，对应 `2^n` 个小方格。格子的二进制标号按 **格雷码（Gray code）** 排列（使相邻格子的编号只有一位不同）。
   - 常见布局：
     - 2 变量：2×2；
     - 3 变量：2 行×4 列（行表示最高位，列为两低位的格雷码顺序 00,01,11,10）；
     - 4 变量：4 行×4 列（行、列均为两位格雷码：00,01,11,10）。
2. **圈的大小**
   - 只能圈 `2^k`（k = 0,1,2,...）个相邻格子（即 1、2、4、8…）。
   - 圈必须是矩形（允许正方形）并且边界可“环绕”（图两边相邻，称 wrap-around），例如最左列与最右列相邻；最上行与最下行相邻。
3. **圈的原则**
   - 优先圈 **尽可能大的** 2^k 个相邻的 `1`（越大消去的变量越多）。
   - 每一个 `1` 必须至少被**一个**圈覆盖（但每个 `1` 可以被多个圈覆盖）。
   - **每个圈至少要包含一个“独立的 1”**（essential 1/独立 1），否则该圈可能是多余的（避免多余项）。
   - 圈的数量应尽可能少，且尽可能覆盖更多 `1`（使表达式项数最少）。
4. **如何从圈得到乘积项（与项）**
   - 在圈中，找出在圈内不发生变化（始终为 0 或始终为 1）的变量。
   - 若变量在圈内恒为 1，则在乘积项中保留该变量（原变量）；若恒为 0，则在乘积项中保留该变量的反（补）形式；若变量在圈内既 0 又 1（发生变化），则该变量在乘积项中被**消去**（不出现）。
   - 最后把所有圈得到的乘积项作或（相加）就是化简后的与-或式（积之和）。
5. **`don't-care`（无关项）的处理**
   - `don't-care`（通常用 `d` 表示）是指某些输入组合在实际应用中不会出现或其输出不关心，这些格子在 K 图中既可以按 1 看待也可以按 0 看待，用来**帮助形成更大的圈**以获得更简的解。
   - 规则：在圈时**可以把 d 当作 1 使用以扩大圈**，但最终表达式不需要为 d 单独输出（即不强制要求包含 d）。
6. **最简式可能不唯一**
   - 不同的圈法可能产生不同但等价的最简表达式；因此出现多解是正常的。

------

## 实操要点 / 易错点（总结）

- 列/行必须按 **格雷码** 排列（否则相邻概念失效）。
- 圈只能是 2 的次方个格子，且要成矩形（不能 L 形）。
- 圈可以重叠；合理重叠能减少项数。
- `1` 必须被覆盖，但不要为了覆盖而生成冗余的圈（优先圈必需的“本质素蕴涵项”）。
- 使用 `don't-care` 时小心：把 d 当 1 用是为了简化，但如果不必要就不要把它当 1；d 的使用只为取得更大圈、更多消去变量。
- 最后要逐个最小项核对（用代数或真值表）确保化简后的表达式覆盖所有原始为 1 的输入。

------

## 例子 1 — **3 变量**（最直接、说明圈与结果的规则）

**定义**：令三个变量为 `A,B,C`（A 为最高位）。
 设函数

```
F(A,B,C) = Σ m(1,3,5,7)
```

（即当输入为 001、011、101、111 时输出为 1）

**步骤**：

1. 画 3-变量 K 图（2 行 × 4 列），列的 BC 顺序为 `00,01,11,10`（格雷码），行 A 为 `0`（上）与 `1`（下）。
2. 标出 1 的格子：m1(001)、m3(011)、m5(101)、m7(111) —— 这四个格子恰好是**两列的同一列（列对应 C=1）**的上下两个单元：实际上这 4 个都是 C = 1 的组合（不论 A、B 为何）。
3. 围成**一个 4 格的列圈**（最大可能），该圈覆盖所有四个 1。
4. 从圈中看变量不变的：`C` 在圈中恒为 `1`（列固定），而 `A`、`B` 在圈内变化（被消去）。
5. 因此乘积项为 `C`。 最终：

```
F = C
```

**结论/说明**：这个例子演示了“把尽可能多的 1 包成大圈”能直接消去多数变量，得到极简表达式。

------

## 例子 2 — **4 变量**（含 `don't-care` 的实用示例：说明如何利用 d 扩大圈并得到更少的项）

设 4 个变量为 `A,B,C,D`（`AB` 行、`CD` 列，行/列的顺序均为格雷码 `00,01,11,10`）。
 定义函数（示例）：

```
F(A,B,C,D) = Σ m(0,2,5,7,8,10)
don't-care d = Σ m(1,3,9,11)
```

### 1) 把最小项与 d 填入 K 图（表格化表示）

下面给出 K-map 的排列（行 = AB：00 / 01 / 11 / 10；列 = CD：00 / 01 / 11 / 10）并标注 minterm 编号：

```
K-map index layout (rows AB, cols CD):
       CD
       00   01   11   10
AB
00     m0   m1   m3   m2
01     m4   m5   m7   m6
11     m12  m13  m15  m14
10     m8   m9   m11  m10
```

将给定的 1 / d 填入（X 表示 1， d 表示 don't-care，空白为 0）：

```
       CD
       00   01   11   10
AB
00     X    d    d    X     (m0=1, m1=d, m3=d, m2=1)
01     .    X    X    .     (m4=., m5=1, m7=1, m6=.)
11     .    .    .    .     (m12..m15 all 0 / not used here)
10     X    d    d    X     (m8=1, m9=d, m11=d, m10=1)
```

（`.` 表示 0 / 空）

### 2) 寻找并圈出尽可能大的 2^k 相邻块（允许使用 d 作为 1）

- **目标**：用尽量少且尽量大的圈覆盖所有 X（真实的 1），可以把 d 看作 1 以便扩大圈。

**圈法建议与选择**：

1. 可以把左上 2×2（由 m0, m1(d), m8, m9(d) 组成）圈成一个 4 格（cover m0 & m8 plus d's）。这个圈对应 `B' C'`（见下文推导）。
2. 类似地，把右下两列（col `11` 与 `10`）在上/下合并利用 d，或把 m2、m10 与相邻的 d（m3、m11）围成 4 格，得到 `B' C`。
3. 对 m5、m7（位于 AB=01 行，列 01 和 11）可以圈成一个 1×2 的横向圈（这将保留 A'·B·D，因为 D=1 恒定，A'=1 恒定，B=1 恒定），也可以检查是否有更大的圈通过别的 d 扩大（此示例中 m5 与 m7 最简是由 A'·B·D 覆盖）。

下面给出一个**合理的最简覆盖**（示范）：

- **圈 A（4 格）**：覆盖 m0, m1(d), m8, m9(d) → 形成一个 2×2 块（左上与左下两行、左两列）。
  - 在该圈中：
    - 对列（CD）来看，列为 `00` 与 `01`，它们的 C 位均为 `0`（C = 0 恒定），D 变化 → D 被消去；
    - 对行（AB）来看，行为 `00` 与 `10`，对应 B = 0 恒定（A 变化） → A 被消去，B = 0 成为常量（记作 B'）。
  - 因此乘积项为 `B' C'`（B=0 → B'，C=0 → C'）。
- **圈 B（4 格）**：覆盖 m2, m3(d), m10, m11(d) → 形成右侧两列同样的 2×2 块。
  - 在该圈中：列为 `11` 与 `10`（两列均有 C = 1 恒定），行为 `00` 与 `10`（B = 0 恒定），得到 `B' C`。
     -（注意：如果不使用 d，则可能需要两个 1×1 或 1×2 的小圈；使用 d 能把它们合并为更大圈，从而消去更多变量。）
- **圈 C（2 格）**：覆盖 m5 与 m7（AB = 01 行，CD = 01 与 11 两列）
  - 在该圈中：行固定为 `01` → A = 0（A'），B = 1；列两格 CD=01 与 CD=11 对应 D = 1 恒定、C 变化 → C 被消去，D 保留。
  - 乘积项为 `A' B D`。

### 3) 写出化简表达式（把每个圈对应的乘积项求或）

将上面三圈对应的乘积项相加：

```
F = B' C'  +  B' C  +  A' B D
```

注意：`B' C' + B' C = B' (C' + C) = B'`，因此可以进一步化简：

```
F = B'  +  A' B D
```

### 4) 验证（直观检查覆盖了所有原始 1）

- `B'` 覆盖了所有 B = 0 的情况（AB 行 00 与 10），即包含 m0, m2, m8, m10（以及包含在 d 的格子），这些都是原始的 1。
- `A' B D` 覆盖 AB=01 且 D=1 的格子，即 m5、m7。
- 因此所有原始的 1（m0,m2,m5,m7,m8,m10）都被覆盖，且没有需要单独覆盖的遗留 1。表达式正确且更简。

------

## 如何把“圈”直接转成代数项（快速记法）

- 找圈 → 找该圈中不变（恒 0 或恒 1）的变量 → 转成乘积：
  - 恒为 1 → 写出该变量（不补）。
  - 恒为 0 → 写出该变量的反（`'` 或 `¯` 表示）。
  - 在圈内变化（既有 0 又有 1）→ 该变量不出现。
- 例如：圈里若 `A` 固定为 0，`B` 固定为 1，`C,D` 变化 → 项为 `A' B`（C、D 被消去）。

------

## 关于“本质素蕴涵项（Essential Prime Implicant）”的补充（用于判定谁必须被选）

- **素蕴涵项（Prime Implicant）**：不能再扩大（再包含更多 1）且覆盖若干原始 1 的圈（表示一个不可再合并的乘积项）。
- **本质素蕴涵项（Essential PI）**：覆盖至少一个仅由该 PI 覆盖到的 `1`（即该 `1` 只被这个 PI 覆盖），因此该 PI 在最小覆盖中是必需的。
- 化简流程中常先找出所有本质素蕴涵项并选上它们，然后用剩下的素蕴涵项来覆盖未覆盖的 `1`，以得到最小覆盖（若存在选择冗余则需比较并选择最优组合）。

------

## 练习建议（如何练好卡诺图化简）

1. **初级**：做很多 3 变量 / 4 变量的 K 图练习，重点练习格雷码位置与相邻判断。
2. **中级**：做含 `don't-care` 的题目，练习何时把 d 当作 1 使用（当能扩大圈并减少项时就用）。
3. **高级**：学习识别本质素蕴涵项与冗余覆盖问题（多解情况），尝试多种圈法并比较项数与每项变量数，培养选择“成本最低”的感觉。
4. **工具辅助**：当变量增多（≥5）时，卡诺图不便，学习使用 Quine–McCluskey 或 布尔代数化简软件 / 仿真工具（但理解卡诺图有助于直觉）
