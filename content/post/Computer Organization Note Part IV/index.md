---
author: "lazy"
title: "Computer Organization Note Part IV"
date: "2025-10-12"
description: "指令系统"
tags:
  - "Computer Organization"
categories:
  - "UESTC"
---

## 引言：指令与指令系统

### 1. 计算机中的信息分类

计算机是处理信息的工具，其内部处理的信息可以分为两大类：

- **数据型信息 (Data)**: 这是计算机程序加工和处理的对象。
  - **数值型数据**: 如整数、浮点数，用于算术运算。
  - **非数值型数据**: 如字符、字符串、逻辑值，用于逻辑判断和人机交互。
- **控制型信息 (Control)**: 这是指导计算机如何操作的命令。
  - **指令 (Instruction)**: 宏观层面上，CPU能够识别和执行的命令。
  - **微命令 (Micro-command)**: 微观层面上，构成一条指令的更基本、更底层的控制信号。

### 2. 计算机的工作步骤

计算机的运行本质上就是周而复始地执行指令序列，其基本工作流程包含三个步骤：

1. **取指令 (Instruction Fetch)**: CPU根据程序计数器 (PC) 的指示，从主存储器中取出下一条要执行的指令。
2. **执行指令 (Instruction Execute)**: CPU对指令进行译码，并根据指令要求执行相应的操作（如算术逻辑运算）。在此过程中，可能还需要从主存或寄存器中获取操作数。
3. **存放结果 (Store Result)**: 将执行指令后得到的结果写回到主存或寄存器中。

### 3. 指令与指令系统的定义

- **指令 (Instruction)**: 指示计算机执行某种操作的命令。它是一系列按照特定格式排列的二进制代码，CPU可以识别并执行。

- **指令系统 (Instruction Set) / 指令集架构 (ISA)**: 一台计算机所能识别和执行的**全部指令的集合**。它是计算机硬件功能与软件之间的接口，直接反映了CPU所具备的功能。

  

## 2.1 指令格式

指令格式定义了指令的二进制结构，即哪些位代表什么含义。

### 1. 指令基本格式

一条指令通常包含两部分核心信息：

- **操作码 (Opcode, OP)**: 指定了该指令要执行的**操作类型**，如加法、减法、数据传送等。**一条指令中有且仅有一个操作码**。
- **地址码 (Address, AD)**: 指定了参与操作的**操作数的位置**或指令执行后**结果的存放位置**。一条指令中可以有0个、1个、2个或3个地址码。

**基本格式:**

```
+--------------+-----------------+
|   操作码 OP   |     地址码 A     |
+--------------+-----------------+
```

### 2. 指令字长

指令字长是指一条指令所占用的二进制位数。

- **优点**: 指令字长越长，可以包含更复杂的操作码和更多的地址信息，从而使指令功能更丰富。
- **缺点**: 指令字长越长，会占用更多的存储空间，并且从主存中取指令需要更长的时间，这会降低指令的执行速度。

> **“瓶颈”问题**: CPU的内部处理速度远快于访问主存储器的速度。例如，一个2GHz的CPU，其内部操作周期约为0.5纳秒 (ns)，而访问一次主存可能需要5纳秒 (ns)，速度相差一个数量级。因此，频繁地访问主存（如取长指令）会成为性能瓶颈。



### 3. 操作码结构

操作码的位数决定了指令系统能支持多少种不同的操作。

#### (1) 定长操作码

所有指令的操作码都具有相同的长度和固定的位置（通常在指令的最高位部分）。这种方式译码简单，但可能会限制指令总数或浪费指令空间。

#### (2) 扩展操作码

指令字长固定，但操作码的长度可变。其核心思想是，让地址码较少的指令拥有更长的操作码，从而在不增加指令总长度的前提下，支持更多的指令类型。

**示例**: 假设指令字长为16位，地址码每个占4位。设计一个支持15条三地址指令、15条二地址指令、15条一地址指令和16条零地址指令的系统。

- **三地址指令 (15条)**
  - `OP(4位) | A1(4位) | A2(4位) | A3(4位)`
  - 操作码 `0000` 到 `1110` (15条)。
  - `1111` 作为**扩展标志**，表示这不是一条三地址指令。
- **二地址指令 (15条)**
  - `1111 | OP'(4位) | A1(4位) | A2(4位)`
  - 前4位 `1111` 表示扩展。
  - OP' 从 `0000` 到 `1110` (15条)。
  - `1111 1111` 作为下一级的扩展标志。
- **一地址指令 (15条)**
  - `1111 | 1111 | OP''(4位) | A1(4位)`
  - 前8位 `1111 1111` 表示扩展。
  - OP'' 从 `0000` 到 `1110` (15条)。
  - `1111 1111 1111` 作为下一级的扩展标志。
- **零地址指令 (16条)**
  - `1111 | 1111 | 1111 | OP'''(4位)`
  - 前12位 `1111 1111 1111` 表示扩展。
  - OP''' 从 `0000` 到 `1111` (16条)，这里不再需要扩展标志，所以4位可以全部用来编码。

#### (3) 方式码

将操作码字段划分为几个部分，每个部分代表一种操作属性或方式。例如，一个算术逻辑指令的操作码可以分为：基本操作、是否影响进位、是否移位、结果是否回送等部分。



### 4. 指令中的地址结构

#### (1) 操作数的位置

操作数可以存放在：

- **CPU内部寄存器**: 访问速度最快。
- **主存储器 (包括Cache)**: 速度次之。
- **外存**: 速度最慢，CPU不能直接访问，需先调入内存。
- **堆栈 (Stack)**: 一种特殊的内存区域，按“后进先出”(LIFO)原则组织数据。

#### (2) 显地址与隐地址

- **显地址 (Explicit Address)**: 在指令中明确地给出了操作数的地址（如内存单元号或寄存器编号）。
- **隐地址 (Implicit Address)**: 指令中不给出地址，而是通过系统事先的约定来确定操作数的位置。例如，约定累加器(AC)总是作为其中一个操作数和结果的存放地。使用隐地址是**简化地址结构、缩短指令长度**的基本途径。

#### (3) 按地址码数量分类

- **四地址指令**: `OP | A1 | A2 | A3 | A4`
  - 功能: `(A1) OP (A2) -> A3`, `下一条指令在A4`
  - 非常罕见，因为程序通常是顺序执行的，A4大部分情况下是多余的。
- **三地址指令**: `OP | A1 | A2 | A3`
  - 功能: `(A1) OP (A2) -> A3`
  - 下一条指令地址由**程序计数器(PC)** 隐含提供: `(PC) + n -> PC`。
- **二地址指令**: `OP | A1 | A2`
  - 功能: `(A1) OP (A2) -> A1` (或 A2)。结果覆盖其中一个操作数。
  - 这是最常见的指令格式之一，如 `ADD AX, BX`。
- **一地址指令**: `OP | A1`
  - **双操作数指令**: 一个操作数在A1，另一个操作数隐含在累加器(AC)中。功能: `(A1) OP (AC) -> AC`。
  - **单操作数指令**: 只对A1处的一个操作数进行操作。功能: `OP(A1) -> A1`，如 `NOT BL` (按位取反)。
- **零地址指令**: `OP`
  - 不含地址码。操作数通常隐含在**堆栈的顶部**。例如，`PUSH` 和 `POP` 指令。
  - 也包括一些不需要操作数的指令，如 `NOP` (空操作) 和 `HLT` (停机)。

## 2.2 指令寻址方式 (重点与难点)

**寻址方式**定义了指令中的地址码字段应该如何解释，以最终找到所需的操作数。### 四大类寻址方式

1. **立即寻址**: 指令中直接包含操作数本身。

2. **直接寻址类**: 指令中直接给出操作数的地址（主存单元号或寄存器号）。

3. **间接寻址类**: 指令中给出的是一个地址指针，需要通过该指针再次访问才能找到操作数。

4. **变址类**: 指令中给出的地址需要和某个寄存器的内容相加，才能得到最终的有效地址。

   

### 详细解析各种寻址方式

#### (1) 立即寻址 (Immediate Addressing)

- **定义**: 地址码字段给出的不是地址，而是**操作数本身**。
- **优点**: 取出指令的同时就获得了操作数，无需再次访存，速度快。
- **缺点**: 操作数大小受到地址码位数的限制。
- **示例**: `MOV AX, 1234H` (将立即数`1234H`送入AX寄存器)。

#### (2) 直接寻址类

- **主存直接寻址**: 指令中直接给出操作数在**主存中的有效地址**。
  - **优点**: 简单直观。
  - **缺点**: 地址码位数决定了可寻址空间的大小，灵活性差。
  - **关系**: `操作数 = (A)`，其中 A 是指令中给出的地址。
  - **示例**: `MOV AX, [2000H]` (将内存地址`2000H`单元的内容送入AX)。
- **寄存器寻址**: 指令中直接给出操作数所在的**寄存器编号**。
  - **优点**: 无需访问主存，速度极快；寄存器数量少，地址码短，指令长度也短。这是现代CPU提高性能的重要手段。
  - **关系**: `操作数 = (Ri)`，其中 Ri 是指令中指定的寄存器。
  - **示例**: `MOV AX, BX` (将BX寄存器的内容送入AX)。

#### (3) 间接寻址类

- **主存间接寻址**: 指令中给出的地址是**存放操作数地址的内存单元的地址**。
  - **过程**: 需要两次访问主存才能获得操作数。
  - **优点**: 扩大了寻址范围（地址码位数不变，但可以指向更大的地址空间），便于编程（如实现指针）。
  - **关系**: `有效地址 = (A)`, `操作数 = ((A))`。
  - **示例**: 指令地址码为`2000H`，`2000H`单元内容为`3000H`，`3000H`单元内容为`AC00H`。最终得到的操作数是`AC00H`。
- **寄存器间接寻址**: 指令中给出寄存器编号，该**寄存器中存放的是操作数的有效地址**。
  - **过程**: 访问1次寄存器和1次主存。
  - **优点**: 结合了寄存器寻址的速度和间接寻址的灵活性。
  - **关系**: `有效地址 = (Ri)`, `操作数 = ((Ri))`。
  - **示例**: `MOV AX, [BX]` (将DS段中，由BX寄存器内容所指向的内存单元的数据送入AX)。
- **自增/自减型寄存器间址**:
  - **自增型 `(R)+`**: 先按寄存器内容寻址，获取操作数后，再将寄存器内容自动加1（或一个字长）。常用于处理连续数据块。
  - **自减型 `-(R)`**: 先将寄存器内容自动减1（或一个字长），再按新的寄存器内容寻址。
- **堆栈寻址**:
  - 操作数隐含在堆栈顶部。地址由**堆栈指针寄存器(SP)** 给出。
  - **压栈 (PUSH)**: `(SP) - 1 -> SP`, `数据 -> ((SP))` (先移动指针，再存数据)。
  - **弹栈 (POP)**: `数据 <- ((SP))`, `(SP) + 1 -> SP` (先取数据，再移动指针)。
  - 这是一种特殊的寄存器间址方式。

#### (4) 变址类 (地址计算)

这类寻址方式的**有效地址 (EA)** 是由指令中给出的**形式地址D**和某个寄存器的内容计算得出的。

- **变址寻址**: `EA = (Rx) + D`

  - **Rx**: 变址寄存器 (如SI, DI)，内容可变，通常用于访问数组或字符串中的元素。

  - **D**: 形式地址，是基准量，固定不变。

  - **面向用户**，用于处理成批数据。

  - **示例**: `MOV AX, 10H[SI]` (EA = (SI) + 10H)。

    

## 2.3 指令类型

### 1. 指令分类方法

- **按指令格式分类**: 双操作数、单操作数指令等。
- **按寻址方式分类**: RR型 (寄存器-寄存器)、RX型 (寄存器-内存) 等。
- **按指令功能分类**: 这是最常用、最重要的方法。

### 2. 按功能分类的指令

#### (1) 传送类指令

- **一般传送指令 (MOV, LOAD, STORE)**: 在寄存器之间、寄存器与内存之间、内存与内存之间（通常不直接支持）传送数据。
- **堆栈指令 (PUSH, POP)**: 对堆栈进行压入和弹出操作。
- **数据交换指令 (XCHG)**: 交换两个操作数的内容。

#### (2) 输入/输出 (I/O) 指令

用于主机与外设之间的数据交换，本质上也是一种传送指令。

- **外围设备编址方式**:
  1. **单独编址 (Isolated I/O)**:
     - I/O设备拥有独立的地址空间，称为**端口地址**。
     - 需要专用的I/O指令 (如 `IN`, `OUT`) 来访问。
     - **优点**: I/O操作与内存操作易于区分，不占用内存地址空间。
     - **缺点**: 需要额外的控制信号线 (I/O Read, I/O Write)。
  2. **统一编址 (Memory-Mapped I/O)**:
     - 将I/O设备的接口寄存器看作主存单元，分配主存地址。
     - 可以使用通用的数据传送指令 (如 `MOV`) 来访问I/O设备。
     - **优点**: 指令类型更少，寻址方式更灵活。
     - **缺点**: 占用主存地址空间。
- **I/O指令的设置方法**:
  1. **设置专用I/O指令**: 对应单独编址方式，如 `IN AL, 20H` (从端口20H读一字节到AL)。
  2. **采用通用数据传送指令**: 对应统一编址方式。
  3. **通过I/O处理器**: CPU向I/O处理器发送通用的命令字，由I/O处理器解释并执行具体的外设操作。

