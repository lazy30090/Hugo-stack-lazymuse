[{"content":"引言：指令与指令系统 1. 计算机中的信息分类 计算机是处理信息的工具，其内部处理的信息可以分为两大类：\n数据型信息 (Data): 这是计算机程序加工和处理的对象。 数值型数据: 如整数、浮点数，用于算术运算。 非数值型数据: 如字符、字符串、逻辑值，用于逻辑判断和人机交互。 控制型信息 (Control): 这是指导计算机如何操作的命令。 指令 (Instruction): 宏观层面上，CPU能够识别和执行的命令。 微命令 (Micro-command): 微观层面上，构成一条指令的更基本、更底层的控制信号。 2. 计算机的工作步骤 计算机的运行本质上就是周而复始地执行指令序列，其基本工作流程包含三个步骤：\n取指令 (Instruction Fetch): CPU根据程序计数器 (PC) 的指示，从主存储器中取出下一条要执行的指令。 执行指令 (Instruction Execute): CPU对指令进行译码，并根据指令要求执行相应的操作（如算术逻辑运算）。在此过程中，可能还需要从主存或寄存器中获取操作数。 存放结果 (Store Result): 将执行指令后得到的结果写回到主存或寄存器中。 3. 指令与指令系统的定义 指令 (Instruction): 指示计算机执行某种操作的命令。它是一系列按照特定格式排列的二进制代码，CPU可以识别并执行。\n指令系统 (Instruction Set) / 指令集架构 (ISA): 一台计算机所能识别和执行的全部指令的集合。它是计算机硬件功能与软件之间的接口，直接反映了CPU所具备的功能。\n2.1 指令格式 指令格式定义了指令的二进制结构，即哪些位代表什么含义。\n1. 指令基本格式 一条指令通常包含两部分核心信息：\n操作码 (Opcode, OP): 指定了该指令要执行的操作类型，如加法、减法、数据传送等。一条指令中有且仅有一个操作码。 地址码 (Address, AD): 指定了参与操作的操作数的位置或指令执行后结果的存放位置。一条指令中可以有0个、1个、2个或3个地址码。 基本格式:\n1 2 3 +--------------+-----------------+ | 操作码 OP | 地址码 A | +--------------+-----------------+ 2. 指令字长 指令字长是指一条指令所占用的二进制位数。\n优点: 指令字长越长，可以包含更复杂的操作码和更多的地址信息，从而使指令功能更丰富。 缺点: 指令字长越长，会占用更多的存储空间，并且从主存中取指令需要更长的时间，这会降低指令的执行速度。 “瓶颈”问题: CPU的内部处理速度远快于访问主存储器的速度。例如，一个2GHz的CPU，其内部操作周期约为0.5纳秒 (ns)，而访问一次主存可能需要5纳秒 (ns)，速度相差一个数量级。因此，频繁地访问主存（如取长指令）会成为性能瓶颈。\n3. 操作码结构 操作码的位数决定了指令系统能支持多少种不同的操作。\n(1) 定长操作码 所有指令的操作码都具有相同的长度和固定的位置（通常在指令的最高位部分）。这种方式译码简单，但可能会限制指令总数或浪费指令空间。\n(2) 扩展操作码 指令字长固定，但操作码的长度可变。其核心思想是，让地址码较少的指令拥有更长的操作码，从而在不增加指令总长度的前提下，支持更多的指令类型。\n示例: 假设指令字长为16位，地址码每个占4位。设计一个支持15条三地址指令、15条二地址指令、15条一地址指令和16条零地址指令的系统。\n三地址指令 (15条) OP(4位) | A1(4位) | A2(4位) | A3(4位) 操作码 0000 到 1110 (15条)。 1111 作为扩展标志，表示这不是一条三地址指令。 二地址指令 (15条) 1111 | OP'(4位) | A1(4位) | A2(4位) 前4位 1111 表示扩展。 OP\u0026rsquo; 从 0000 到 1110 (15条)。 1111 1111 作为下一级的扩展标志。 一地址指令 (15条) 1111 | 1111 | OP''(4位) | A1(4位) 前8位 1111 1111 表示扩展。 OP\u0026rsquo;\u0026rsquo; 从 0000 到 1110 (15条)。 1111 1111 1111 作为下一级的扩展标志。 零地址指令 (16条) 1111 | 1111 | 1111 | OP'''(4位) 前12位 1111 1111 1111 表示扩展。 OP\u0026rsquo;\u0026rsquo;\u0026rsquo; 从 0000 到 1111 (16条)，这里不再需要扩展标志，所以4位可以全部用来编码。 (3) 方式码 将操作码字段划分为几个部分，每个部分代表一种操作属性或方式。例如，一个算术逻辑指令的操作码可以分为：基本操作、是否影响进位、是否移位、结果是否回送等部分。\n4. 指令中的地址结构 (1) 操作数的位置 操作数可以存放在：\nCPU内部寄存器: 访问速度最快。 主存储器 (包括Cache): 速度次之。 外存: 速度最慢，CPU不能直接访问，需先调入内存。 堆栈 (Stack): 一种特殊的内存区域，按“后进先出”(LIFO)原则组织数据。 (2) 显地址与隐地址 显地址 (Explicit Address): 在指令中明确地给出了操作数的地址（如内存单元号或寄存器编号）。 隐地址 (Implicit Address): 指令中不给出地址，而是通过系统事先的约定来确定操作数的位置。例如，约定累加器(AC)总是作为其中一个操作数和结果的存放地。使用隐地址是简化地址结构、缩短指令长度的基本途径。 (3) 按地址码数量分类 四地址指令: OP | A1 | A2 | A3 | A4 功能: (A1) OP (A2) -\u0026gt; A3, 下一条指令在A4 非常罕见，因为程序通常是顺序执行的，A4大部分情况下是多余的。 三地址指令: OP | A1 | A2 | A3 功能: (A1) OP (A2) -\u0026gt; A3 下一条指令地址由程序计数器(PC) 隐含提供: (PC) + n -\u0026gt; PC。 二地址指令: OP | A1 | A2 功能: (A1) OP (A2) -\u0026gt; A1 (或 A2)。结果覆盖其中一个操作数。 这是最常见的指令格式之一，如 ADD AX, BX。 一地址指令: OP | A1 双操作数指令: 一个操作数在A1，另一个操作数隐含在累加器(AC)中。功能: (A1) OP (AC) -\u0026gt; AC。 单操作数指令: 只对A1处的一个操作数进行操作。功能: OP(A1) -\u0026gt; A1，如 NOT BL (按位取反)。 零地址指令: OP 不含地址码。操作数通常隐含在堆栈的顶部。例如，PUSH 和 POP 指令。 也包括一些不需要操作数的指令，如 NOP (空操作) 和 HLT (停机)。 2.2 指令寻址方式 (重点与难点) 寻址方式定义了指令中的地址码字段应该如何解释，以最终找到所需的操作数。### 四大类寻址方式\n立即寻址: 指令中直接包含操作数本身。\n直接寻址类: 指令中直接给出操作数的地址（主存单元号或寄存器号）。\n间接寻址类: 指令中给出的是一个地址指针，需要通过该指针再次访问才能找到操作数。\n变址类: 指令中给出的地址需要和某个寄存器的内容相加，才能得到最终的有效地址。\n详细解析各种寻址方式 (1) 立即寻址 (Immediate Addressing) 定义: 地址码字段给出的不是地址，而是操作数本身。 优点: 取出指令的同时就获得了操作数，无需再次访存，速度快。 缺点: 操作数大小受到地址码位数的限制。 示例: MOV AX, 1234H (将立即数1234H送入AX寄存器)。 (2) 直接寻址类 主存直接寻址: 指令中直接给出操作数在主存中的有效地址。 优点: 简单直观。 缺点: 地址码位数决定了可寻址空间的大小，灵活性差。 关系: 操作数 = (A)，其中 A 是指令中给出的地址。 示例: MOV AX, [2000H] (将内存地址2000H单元的内容送入AX)。 寄存器寻址: 指令中直接给出操作数所在的寄存器编号。 优点: 无需访问主存，速度极快；寄存器数量少，地址码短，指令长度也短。这是现代CPU提高性能的重要手段。 关系: 操作数 = (Ri)，其中 Ri 是指令中指定的寄存器。 示例: MOV AX, BX (将BX寄存器的内容送入AX)。 (3) 间接寻址类 主存间接寻址: 指令中给出的地址是存放操作数地址的内存单元的地址。 过程: 需要两次访问主存才能获得操作数。 优点: 扩大了寻址范围（地址码位数不变，但可以指向更大的地址空间），便于编程（如实现指针）。 关系: 有效地址 = (A), 操作数 = ((A))。 示例: 指令地址码为2000H，2000H单元内容为3000H，3000H单元内容为AC00H。最终得到的操作数是AC00H。 寄存器间接寻址: 指令中给出寄存器编号，该寄存器中存放的是操作数的有效地址。 过程: 访问1次寄存器和1次主存。 优点: 结合了寄存器寻址的速度和间接寻址的灵活性。 关系: 有效地址 = (Ri), 操作数 = ((Ri))。 示例: MOV AX, [BX] (将DS段中，由BX寄存器内容所指向的内存单元的数据送入AX)。 自增/自减型寄存器间址: 自增型 (R)+: 先按寄存器内容寻址，获取操作数后，再将寄存器内容自动加1（或一个字长）。常用于处理连续数据块。 自减型 -(R): 先将寄存器内容自动减1（或一个字长），再按新的寄存器内容寻址。 堆栈寻址: 操作数隐含在堆栈顶部。地址由堆栈指针寄存器(SP) 给出。 压栈 (PUSH): (SP) - 1 -\u0026gt; SP, 数据 -\u0026gt; ((SP)) (先移动指针，再存数据)。 弹栈 (POP): 数据 \u0026lt;- ((SP)), (SP) + 1 -\u0026gt; SP (先取数据，再移动指针)。 这是一种特殊的寄存器间址方式。 (4) 变址类 (地址计算) 这类寻址方式的有效地址 (EA) 是由指令中给出的形式地址D和某个寄存器的内容计算得出的。\n变址寻址: EA = (Rx) + D\nRx: 变址寄存器 (如SI, DI)，内容可变，通常用于访问数组或字符串中的元素。\nD: 形式地址，是基准量，固定不变。\n面向用户，用于处理成批数据。\n示例: MOV AX, 10H[SI] (EA = (SI) + 10H)。\n2.3 指令类型 1. 指令分类方法 按指令格式分类: 双操作数、单操作数指令等。 按寻址方式分类: RR型 (寄存器-寄存器)、RX型 (寄存器-内存) 等。 按指令功能分类: 这是最常用、最重要的方法。 2. 按功能分类的指令 (1) 传送类指令 一般传送指令 (MOV, LOAD, STORE): 在寄存器之间、寄存器与内存之间、内存与内存之间（通常不直接支持）传送数据。 堆栈指令 (PUSH, POP): 对堆栈进行压入和弹出操作。 数据交换指令 (XCHG): 交换两个操作数的内容。 (2) 输入/输出 (I/O) 指令 用于主机与外设之间的数据交换，本质上也是一种传送指令。\n外围设备编址方式: 单独编址 (Isolated I/O): I/O设备拥有独立的地址空间，称为端口地址。 需要专用的I/O指令 (如 IN, OUT) 来访问。 优点: I/O操作与内存操作易于区分，不占用内存地址空间。 缺点: 需要额外的控制信号线 (I/O Read, I/O Write)。 统一编址 (Memory-Mapped I/O): 将I/O设备的接口寄存器看作主存单元，分配主存地址。 可以使用通用的数据传送指令 (如 MOV) 来访问I/O设备。 优点: 指令类型更少，寻址方式更灵活。 缺点: 占用主存地址空间。 I/O指令的设置方法: 设置专用I/O指令: 对应单独编址方式，如 IN AL, 20H (从端口20H读一字节到AL)。 采用通用数据传送指令: 对应统一编址方式。 通过I/O处理器: CPU向I/O处理器发送通用的命令字，由I/O处理器解释并执行具体的外设操作。 ","date":"2025-10-12T00:00:00Z","permalink":"https://lazy30090.github.io/Hugo-stack-lazymuse/p/computer-organization-note-part-iv/","title":"Computer Organization Note Part IV"},{"content":"《计算机组成原理》：卡诺图 概念回顾（为什么用卡诺图）\n卡诺图是一种以图形方式表示 n 变量逻辑函数最小项（minterm）并进行化简的方法。 通过把逻辑上“相邻”的最小项在几何位置上也安排相邻，可以直观地找到可以合并的项（消去变量），从而得到更简的与-或（积之和）形式。 目标：用尽可能少、尽可能大的“卡诺圈”覆盖所有值为 1 的小格，得到最简或接近最简的表达式（最小项数量少、每项变量数少、并考虑成本与实现）。 基本规则（必须完全掌握） 格子与编号 n 变量共有 2^n 个最小项，对应 2^n 个小方格。格子的二进制标号按 格雷码（Gray code） 排列（使相邻格子的编号只有一位不同）。 常见布局： 2 变量：2×2； 3 变量：2 行×4 列（行表示最高位，列为两低位的格雷码顺序 00,01,11,10）； 4 变量：4 行×4 列（行、列均为两位格雷码：00,01,11,10）。 圈的大小 只能圈 2^k（k = 0,1,2,\u0026hellip;）个相邻格子（即 1、2、4、8…）。 圈必须是矩形（允许正方形）并且边界可“环绕”（图两边相邻，称 wrap-around），例如最左列与最右列相邻；最上行与最下行相邻。 圈的原则 优先圈 尽可能大的 2^k 个相邻的 1（越大消去的变量越多）。 每一个 1 必须至少被一个圈覆盖（但每个 1 可以被多个圈覆盖）。 每个圈至少要包含一个“独立的 1”（essential 1/独立 1），否则该圈可能是多余的（避免多余项）。 圈的数量应尽可能少，且尽可能覆盖更多 1（使表达式项数最少）。 如何从圈得到乘积项（与项） 在圈中，找出在圈内不发生变化（始终为 0 或始终为 1）的变量。 若变量在圈内恒为 1，则在乘积项中保留该变量（原变量）；若恒为 0，则在乘积项中保留该变量的反（补）形式；若变量在圈内既 0 又 1（发生变化），则该变量在乘积项中被消去（不出现）。 最后把所有圈得到的乘积项作或（相加）就是化简后的与-或式（积之和）。 don't-care（无关项）的处理 don't-care（通常用 d 表示）是指某些输入组合在实际应用中不会出现或其输出不关心，这些格子在 K 图中既可以按 1 看待也可以按 0 看待，用来帮助形成更大的圈以获得更简的解。 规则：在圈时可以把 d 当作 1 使用以扩大圈，但最终表达式不需要为 d 单独输出（即不强制要求包含 d）。 最简式可能不唯一 不同的圈法可能产生不同但等价的最简表达式；因此出现多解是正常的。 实操要点 / 易错点（总结） 列/行必须按 格雷码 排列（否则相邻概念失效）。 圈只能是 2 的次方个格子，且要成矩形（不能 L 形）。 圈可以重叠；合理重叠能减少项数。 1 必须被覆盖，但不要为了覆盖而生成冗余的圈（优先圈必需的“本质素蕴涵项”）。 使用 don't-care 时小心：把 d 当 1 用是为了简化，但如果不必要就不要把它当 1；d 的使用只为取得更大圈、更多消去变量。 最后要逐个最小项核对（用代数或真值表）确保化简后的表达式覆盖所有原始为 1 的输入。 例子 1 — 3 变量（最直接、说明圈与结果的规则） 定义：令三个变量为 A,B,C（A 为最高位）。 设函数\n1 F(A,B,C) = Σ m(1,3,5,7) （即当输入为 001、011、101、111 时输出为 1）\n步骤：\n画 3-变量 K 图（2 行 × 4 列），列的 BC 顺序为 00,01,11,10（格雷码），行 A 为 0（上）与 1（下）。 标出 1 的格子：m1(001)、m3(011)、m5(101)、m7(111) —— 这四个格子恰好是**两列的同一列（列对应 C=1）**的上下两个单元：实际上这 4 个都是 C = 1 的组合（不论 A、B 为何）。 围成一个 4 格的列圈（最大可能），该圈覆盖所有四个 1。 从圈中看变量不变的：C 在圈中恒为 1（列固定），而 A、B 在圈内变化（被消去）。 因此乘积项为 C。 最终： 1 F = C 结论/说明：这个例子演示了“把尽可能多的 1 包成大圈”能直接消去多数变量，得到极简表达式。\n例子 2 — 4 变量（含 don't-care 的实用示例：说明如何利用 d 扩大圈并得到更少的项） 设 4 个变量为 A,B,C,D（AB 行、CD 列，行/列的顺序均为格雷码 00,01,11,10）。 定义函数（示例）：\n1 2 F(A,B,C,D) = Σ m(0,2,5,7,8,10) don\u0026#39;t-care d = Σ m(1,3,9,11) 1) 把最小项与 d 填入 K 图（表格化表示） 下面给出 K-map 的排列（行 = AB：00 / 01 / 11 / 10；列 = CD：00 / 01 / 11 / 10）并标注 minterm 编号：\n1 2 3 4 5 6 7 8 K-map index layout (rows AB, cols CD): CD 00 01 11 10 AB 00 m0 m1 m3 m2 01 m4 m5 m7 m6 11 m12 m13 m15 m14 10 m8 m9 m11 m10 将给定的 1 / d 填入（X 表示 1， d 表示 don\u0026rsquo;t-care，空白为 0）：\n1 2 3 4 5 6 7 CD 00 01 11 10 AB 00 X d d X (m0=1, m1=d, m3=d, m2=1) 01 . X X . (m4=., m5=1, m7=1, m6=.) 11 . . . . (m12..m15 all 0 / not used here) 10 X d d X (m8=1, m9=d, m11=d, m10=1) （. 表示 0 / 空）\n2) 寻找并圈出尽可能大的 2^k 相邻块（允许使用 d 作为 1） 目标：用尽量少且尽量大的圈覆盖所有 X（真实的 1），可以把 d 看作 1 以便扩大圈。 圈法建议与选择：\n可以把左上 2×2（由 m0, m1(d), m8, m9(d) 组成）圈成一个 4 格（cover m0 \u0026amp; m8 plus d\u0026rsquo;s）。这个圈对应 B' C'（见下文推导）。 类似地，把右下两列（col 11 与 10）在上/下合并利用 d，或把 m2、m10 与相邻的 d（m3、m11）围成 4 格，得到 B' C。 对 m5、m7（位于 AB=01 行，列 01 和 11）可以圈成一个 1×2 的横向圈（这将保留 A\u0026rsquo;·B·D，因为 D=1 恒定，A\u0026rsquo;=1 恒定，B=1 恒定），也可以检查是否有更大的圈通过别的 d 扩大（此示例中 m5 与 m7 最简是由 A\u0026rsquo;·B·D 覆盖）。 下面给出一个合理的最简覆盖（示范）：\n圈 A（4 格）：覆盖 m0, m1(d), m8, m9(d) → 形成一个 2×2 块（左上与左下两行、左两列）。 在该圈中： 对列（CD）来看，列为 00 与 01，它们的 C 位均为 0（C = 0 恒定），D 变化 → D 被消去； 对行（AB）来看，行为 00 与 10，对应 B = 0 恒定（A 变化） → A 被消去，B = 0 成为常量（记作 B\u0026rsquo;）。 因此乘积项为 B' C'（B=0 → B\u0026rsquo;，C=0 → C\u0026rsquo;）。 圈 B（4 格）：覆盖 m2, m3(d), m10, m11(d) → 形成右侧两列同样的 2×2 块。 在该圈中：列为 11 与 10（两列均有 C = 1 恒定），行为 00 与 10（B = 0 恒定），得到 B' C。 -（注意：如果不使用 d，则可能需要两个 1×1 或 1×2 的小圈；使用 d 能把它们合并为更大圈，从而消去更多变量。） 圈 C（2 格）：覆盖 m5 与 m7（AB = 01 行，CD = 01 与 11 两列） 在该圈中：行固定为 01 → A = 0（A\u0026rsquo;），B = 1；列两格 CD=01 与 CD=11 对应 D = 1 恒定、C 变化 → C 被消去，D 保留。 乘积项为 A' B D。 3) 写出化简表达式（把每个圈对应的乘积项求或） 将上面三圈对应的乘积项相加：\n1 F = B\u0026#39; C\u0026#39; + B\u0026#39; C + A\u0026#39; B D 注意：B' C' + B' C = B' (C' + C) = B'，因此可以进一步化简：\n1 F = B\u0026#39; + A\u0026#39; B D 4) 验证（直观检查覆盖了所有原始 1） B' 覆盖了所有 B = 0 的情况（AB 行 00 与 10），即包含 m0, m2, m8, m10（以及包含在 d 的格子），这些都是原始的 1。 A' B D 覆盖 AB=01 且 D=1 的格子，即 m5、m7。 因此所有原始的 1（m0,m2,m5,m7,m8,m10）都被覆盖，且没有需要单独覆盖的遗留 1。表达式正确且更简。 如何把“圈”直接转成代数项（快速记法） 找圈 → 找该圈中不变（恒 0 或恒 1）的变量 → 转成乘积： 恒为 1 → 写出该变量（不补）。 恒为 0 → 写出该变量的反（' 或 ¯ 表示）。 在圈内变化（既有 0 又有 1）→ 该变量不出现。 例如：圈里若 A 固定为 0，B 固定为 1，C,D 变化 → 项为 A' B（C、D 被消去）。 关于“本质素蕴涵项（Essential Prime Implicant）”的补充（用于判定谁必须被选） 素蕴涵项（Prime Implicant）：不能再扩大（再包含更多 1）且覆盖若干原始 1 的圈（表示一个不可再合并的乘积项）。 本质素蕴涵项（Essential PI）：覆盖至少一个仅由该 PI 覆盖到的 1（即该 1 只被这个 PI 覆盖），因此该 PI 在最小覆盖中是必需的。 化简流程中常先找出所有本质素蕴涵项并选上它们，然后用剩下的素蕴涵项来覆盖未覆盖的 1，以得到最小覆盖（若存在选择冗余则需比较并选择最优组合）。 练习建议（如何练好卡诺图化简） 初级：做很多 3 变量 / 4 变量的 K 图练习，重点练习格雷码位置与相邻判断。 中级：做含 don't-care 的题目，练习何时把 d 当作 1 使用（当能扩大圈并减少项时就用）。 高级：学习识别本质素蕴涵项与冗余覆盖问题（多解情况），尝试多种圈法并比较项数与每项变量数，培养选择“成本最低”的感觉。 工具辅助：当变量增多（≥5）时，卡诺图不便，学习使用 Quine–McCluskey 或 布尔代数化简软件 / 仿真工具（但理解卡诺图有助于直觉） ","date":"2025-10-11T00:00:00Z","permalink":"https://lazy30090.github.io/Hugo-stack-lazymuse/p/computer-organization-note-part-iii/","title":"Computer Organization Note Part III"},{"content":"《计算机组成原理》：数据的表示、运算和校验 1. 进位计数制（Number Systems） 概念 基数（radix）：每位允许的记数符号个数。例如十进制基数 10（0–9）、二进制基数 2（0–1）、八进制 8、十六进制 16（0–F）。 权值（weight）：数位 i 的权值为 base^i。例如十进制中 256.7 = 2×10² + 5×10¹ + 6×10⁰ + 7×10⁻¹。 各进制常见示例 二进制：(101.1)_2 = 1×2² + 0×2¹ + 1×2⁰ + 1×2⁻¹ = 5.5 八进制：(12.4)_8 = 1×8¹ + 2×8⁰ + 4×8⁻¹ = 10.5 十六进制：(3A6)_16 = 3×16² + 10×16¹ + 6 = 934 二进制的运算规则（关键） 加法（单位）：0+0=0；0+1=1；1+1=10（产生进位） 减法、乘法、除法同理（见 PPT 示例） 二进制与十进制互换： 十进制整数→二进制：反复除 2 取余（低位到高位）。 十进制小数→二进制小数：反复乘 2 取整数部分（直到小数为 0 或达到精度）。 二进制→十进制：按权展开求和。 八/十六进制与二进制转换技巧 八进制：每 3 位二进制为一组（从小数点向两侧分组），例如 (1011101.0110101)_2 = (135.324)_8。 十六进制：每 4 位二进制为一组，例如上例也可得到 (5D.6A)_16。 2. 带符号数的表示（符号与机器数） 在计算机中需要把“正/负”变成机器可计算的二进制码，常见三种表示方法（都以最高位为符号位，0 表示正，1 表示负）：\n2.1 原码（Sign-magnitude） 编码规则：最高位为符号位，其余位为数值位的原值不变。 缺陷：存在 +0 和 -0 两种表示，减法运算复杂（需比较大小再决定符号）。 例（8 位）：\n+127 原码 = 0 1111111 −127 原码 = 1 1111111 +0 = 0 0000000，−0 = 1 0000000 2.2 反码（Ones\u0026rsquo; complement） 正数：反码 = 原码（不变） 负数：反码 = 对原码的符号位不变，数值位按位取反（1↔0） 缺点：仍存在 +0 和 -0（0 0000000 与 1 1111111） 例（8 位）：真值 −105\n原码 1 1101001 → 反码 1 0010110 2.3 补码（Two\u0026rsquo;s complement） —— 现代计算机标准 正数：补码 = 原码（不变） 负数：补码 = 反码 + 1（对原码按位取反后最低位加 1） 优点：0 只有一种表示（0...0），加减法能统一为加法（符号位参与运算），硬件实现更简单；还能表示一个额外的最小负数（例如 8 位：−128 可表示）。 例（8 位）：补码表示范围 -128 .. +127。 +127 补码 = 0 1111111，−128 补码 = 1 0000000 常见操作（补码与原码转换） 已知原码求补码（负数）：按位取反后末位 +1。 已知补码求原码：对补码连同符号位一起“变反、末位加 1”（即对负数做再次求补得到原码）。 求 [-X] 的补码：把 X 的补码连同符号位一起取反然后末位 +1（即补码取负的直接变换）。 3. 定点数与浮点数（Fixed-point \u0026amp; Floating-point） 3.1 定点数 定义：程序中约定小数点固定在某一位置（比如全部数的小数点在同一位置）。 有三类： 带符号定点小数：小数点固定在符号位之后；字长 n+1 时，补码表示范围为 -1 .. 1 - 2^-n，分辨率 2^-n。 带符号定点整数：小数点固定在最低数值位之后；补码范围 -2^n .. 2^n -1，分辨率 1。 无符号定点整数：范围 0 .. 2^(n+1)-1。 注意：定点数的小数点位置是约定，并不需要硬件单独表示。 3.2 浮点数（浮点表示法） 基本形式：N = M × R^E（R 通常为 2），其中： M（尾数，mantissa/significand）：带符号的定点小数（规定规格化后范围，使表示唯一）。 E（阶码，exponent）：带符号定点整数，常采用 移码（bias） 表示（如 IEEE754）。 S（符号位）：表示正负。 移码（Bias）：对定点整数 x 的移码表示为 x + 2^(n-1)（使得阶码表现为无符号偏移，便于比较大小与排序）。 规格化（Normalization）：为保证表示唯一，尾数 M 要规格化（例如二进制浮点规定 1/2 ≤ |M| \u0026lt; 1 或 1 ≤ |M| \u0026lt; 2，具体依格式而定）。规格化使最高有效位固定（通常为 1），提高精度利用率。 IEEE 754 简明 32 位单精度（single precision）格式： S（1 位）| E（8 位，移码偏移 127）| M（23 位，尾数的纯小数部分，真值为 1.M 对于正规化数） 真值：F = (-1)^S × 1.M × 2^(E - 127)（当 E 非全 0/全 1 并为正规化数） 特殊情况： E = 0 且 M = 0 → 表示 ±0 E = 0 且 M ≠ 0 → 次正规数（subnormal） E = 255 且 M = 0 → ±∞ E = 255 且 M ≠ 0 → NaN 精度： 单精度尾数 23 位 → 相对精度约 2^-23（加上隐含的 1，则有效精度 24 位）。 示例（PPT）：把 20.59375 转为 IEEE754 单精度： 十进制 → 二进制：20.59375 = 10100.10011 规格化：1.010010011 × 2^4（e = 4） 阶码加偏移：E = 4 + 127 = 131 = 10000011_b 尾数 M = 010010011000...（补齐 23 位） 最终二进制码：0 10000011 01001001100000000000000 → 十六进制 41A4C000。（详见 PPT 步骤）1.1 数据的表示、运算和校验 4. 字符编码（ASCII） ASCII：美国标准信息交换码，使用 7 位二进制，能表示 128 个字符（包括 33 个控制字符和 95 个可打印字符）。 常用区间： 数字 0-9 的十六进制代码为 30h - 39h 大写字母 A-Z：41h - 5Ah 小写字母 a-z：61h - 7Ah 中国还有国家标准编码（如 GB），但 ASCII 在基础英文文本与控制字符上通用。1.1 数据的表示、运算和校验 5. 定点加减运算（使用补码） 5.1 原理 使用补码表示的数（包括符号位）直接相加即可： (X + Y)_补 = X_补 + Y_补 (X - Y)_补 = X_补 + (-Y)_补（把 Y 取补后相加） 全过程以 2^n 为模（即超出位宽的高位丢弃，等价于模运算）。 5.2 示例（逐步） 例 1：X=3, Y=2（假设 5-bit 显示为例） X_补 = 0 0011，Y_补 = 0 0010 → 相加 = 0 0101（+5，无溢出） 例 2：X=-3, Y=-2 X_补 = 1 1101（-3），Y_补 = 1 1110（-2） → 相加得到 1 1011（-5 的补码） 5.3 注意：变补 与 补码 的区别（考点） 变补：把某数连同符号位一起取反，末位加 1 —— 通常用于“对补码求负”或“由补码求相反数”的操作。 补码表示：用于直接表示数值（正数的补码同原码，负数按反码+1）。 6. 溢出判断（Overflow Detection） 当用补码做加减时，结果可能超出机器所能表示的范围——称为溢出。PPT 给出三种硬件判断逻辑（实际任意一种都可实现）：\n常用规则（直观） 加法溢出：当两个同符号数相加，结果与操作数符号不同，则发生溢出。 例如：两个正数相加却得到负数（正溢）；两个负数相加却得到正数（负溢）。 硬件实现方法： 基于操作数和结果符号位：overflow = (SA \u0026amp; SB \u0026amp; ~SF) | (~SA \u0026amp; ~SB \u0026amp; SF)（简化含义：若 SA == SB 且 SF != SA → 溢出）。 基于最高位进位与符号位进位比较：overflow = Cf ⊕ C，其中 C 是尾数最高位的进位，Cf 是符号位的进位（PPT 术语）。 双符号位比较（Sf1 ⊕ Sf2）：使用不同阶段的符号位判断溢出（在硬件设计中有实现方式）。 示例（PPT 的示例） 10 + 7 在某较小位宽会发生正溢（示例中展示了进位与符号关系）。 综上，最简单记忆法：加法时若两个操作数符号相同而结果符号不同，则溢出。 7. 移位运算（Shifts） 移位是位级操作，可以是逻辑移位、算术移位或循环移位。\n7.1 逻辑移位（Logical shift） 左移：在右端补 0，左移相当于乘以 2^n（若无溢出）。 右移：在左端补 0（用于无符号数），相当于无符号除以 2^n（舍去低位）。 7.2 算术移位（Arithmetic shift） 保持符号位不变（最高位保持原符号值），用于带符号整数（补码）右移，相当于算术除以 2（向零或向 -∞ 取整取决实现）。 左移与逻辑左移相同（在多数实现中空位补 0，可能产生溢出）。 7.3 循环移位（Rotate） 左/右移出位从另一端回填（常用于加密与循环缓冲）。 PPT 中的要点（双符号位） 在一些原码乘法算法里，寄存器使用双符号位（第一个符号位保持原符号，第二符号位用于移位进入尾数最高位），移位规则中空位如何补 0/1 要特别注意，尤其是负数右移需补 1。 8. 舍入与截断（Rounding） 常用舍入策略（PPT 提到两种）：\n“0 舍 1 入”（即遇到被丢弃位为 0，则舍弃；为 1，则向上加 1）：类似“向最近偶数/四舍五入”的简化版本。 末位恒置 1：不管被截断位如何，保留位的最低位置 1（一种保守策略，保证不上溢出但不是常用）。 注意：浮点运算中通常使用更复杂且规范的舍入（例如 IEEE754 的 round-to-nearest-even 等）；在定点截断时应明确采用的舍入策略以保证一致性。\n9. 定点乘法（Fixed-point Multiplication） PPT 讲解了原码一位乘法、补码一位乘法（比较法/校正法）等。\n9.1 原码一位乘法（逐位累加移位） 基本思想：把乘数每一位乘以被乘数（形成部分积），把这些部分积按位移位并累加得到乘积（类似小学校算）。 寄存器分配（常见实现）： A：部分积累加和（含两位符号位） B：被乘数的绝对值（保持不变） C：乘数（最低位用于判断），同时存放乘积低位 操作（对尾数位逐位执行）： 若 C_n = 1：A = A + B，然后右移（A 的最低位移入 C 的最高位） 若 C_n = 0：A = A + 0，右移 最后加符号位：结果符号 S_P = S_X ⊕ S_Y（X 与 Y 为被乘数与乘数符号） 示例（PPT）： 0.1101 × 0.1011（均为正，二进制小数），手工步骤列出了部分积与累加，最终乘积为 0.10001111（十进制 ≈ 0.55859375）。 9.2 补码一位乘法（比较法） 校正法： 若乘数 Y 为正，则可按原码乘法（不需校正）。 若乘数为负，需对结果做校正（加或减被乘数补码）。 比较法（更常用）： 用乘数的相邻两位（Y_n 与 Y_{n+1}）比较决定操作： 00 或 11 → A = A / 2（不加） 01 → A = (A + X) / 2 10 → A = (A - X) / 2 该方法减少了每一步的加减次数（属于 Booth 算法的简化思想的一类）。 寄存器与判定位： C 寄存器末位拼接一个附加位 Y_{n+1}（初始为 0），每步检查 Y_n, Y_{n+1}。 示例（PPT）： X = -0.1101, Y = -0.1011（补码表示），通过比较法逐步进行了 A 的更新，最终得到 (XY)_补（中间有修正步骤），示例中列出每一步的 A 与 C 内容，便于对照实现。 9.3 实际实现要点 对补码乘法，寄存器中 B（被乘数）通常保留补码形式（或其负值也预先计算）以便需要时加减。 结果位数通常为两倍尾数位（需预先分配足够寄存器位）。 注意符号位处理（单符号位或双符号位实现的差别），右移时如何填充符号位是关键易错处（参见 PPT 的“易出错处”）。 10. 本章小结（要点回顾） 掌握进制间转换（尤其二/八/十/十六之间的转换技巧与分组规则）。 带符号数的三种表示：原码、反码、补码 —— 理解补码优势并熟练做补码运算与变换。 定点与浮点表示：理解定点表示的约定、小数点位置含义；重点掌握 IEEE754 单精度格式（S/E/M 的位含义、偏移量、特殊值）。 定点加减乘运算实现：补码加法统一处理、溢出判断（符号位规则与进位比对）、移位规则、截断与舍入方法、定点乘法的寄存器算法（原码乘法、补码比较法）。1.1 数据的表示、运算和校验 11. 例题练习（含答案与步骤） 练习 1 — 进制转换 将 (369)_10 转换为八进制和十六进制。 解：369 ÷ 8 得商 46 余 1 → 46 ÷ 8 商 5 余 6 → 5 ÷ 8 商 0 余 5 → 八进制 561。 十六进制：369 = 1×16² + 7×16 + 1 → (171)_16。 （与 PPT 示例一致）1.1 数据的表示、运算和校验 练习 2 — 补码运算与溢出 假设用 8 位补码表示，计算 100 + 50（十进制），判断是否溢出。 100 的 8 位补码 01100100，50 的 8 位补码 00110010，相加得 10010110（最高位 1 表示负），但两操作数均为正而结果为负 → 发生溢出（结果模 256 后表示为 -106，但对有符号数这为溢出）。 练习 3 — IEEE754 转换 将 -6.25 转为 IEEE754 单精度二进制表示。 6.25 = 110.01_b = 1.1001 × 2^2 → exponent = 2 + 127 = 129 = 10000001_b，mantissa = 1001000...（后面补零）。符号 S = 1。 最终：1 10000001 10010000000000000000000 → 十六进制可自行分组转换。 练习 4 — 定点乘法（逐步） 计算 0.1101 × 0.1011（二进制小数，结果保留 8 位），手工按原码乘法步骤： 参见 PPT 的手工乘法展示，最终 0.10001111（十进制 ≈ 0.55859375）。（已在章节中逐位解释）1.1 数据的表示、运算和校验 12. 常见易错点与考试/上机提示 符号位与补码概念混淆：牢记“正数的补码 = 原码”，只有负数需要按位取反加 1。 0 的多重表示：原码/反码存在 +0 / −0；补码只有单一 0。 溢出判断：不要只看最高位进位，使用“两个操作数同符号且结果符号不同”更直观；硬件可以用 Cf ⊕ C 或 Sf1 ⊕ Sf2。 移位时填充规则：算术右移需补符号位（符号扩展）；逻辑右移补 0。 浮点角标偏移（bias）：记住单精度偏移是 127（即 E_stored = E_true + 127）。 浮点特殊值：E 全 0（次正规或 0），E 全 1（±∞ 或 NaN 与 M 非零）。 ","date":"2025-10-10T00:00:00Z","permalink":"https://lazy30090.github.io/Hugo-stack-lazymuse/p/computer-organization-note-part-ii/","title":"Computer Organization Note Part II"},{"content":"IEEE-754 单精度（32 位）—— 表示法详细说明 格式（字段与位宽） 单精度 32 位由三部分组成（从高位到低位）：\nS（符号位）—— 1 位：0 表示正数，1 表示负数。 E（阶码 exponent）—— 8 位：采用**移码（biased）**表示，偏置（bias）为 127（即实际阶码 = 存储值 − 127）。 M（尾数 fraction / significand）—— 23 位：存储的是隐含 1 之后的小数部分（对正规化数，真实尾数为 1.M）。 真值公式（正规化数）： value = (-1)^S × 1.M × 2^(E_stored − 127)。 （当 E_stored 既不是全 0 也不是全 1 时）\n特殊情况（E 与 M 的组合） E = 0 且 M = 0 → ±0（根据 S）。 E = 0 且 M ≠ 0 → 次正规数（subnormal）：真值 (-1)^S × 0.M × 2^(1−127)（没有隐含 1）。 E = 255（即全 1）且 M = 0 → ±∞（正负无穷）。 E = 255 且 M ≠ 0 → NaN（非数）。 一些重要概念 规格化（normalization）：为了保证表示的唯一性，正规化时尾数 M 满足 1 ≤ 1.M \u0026lt; 2（即隐含 1 的最高位是 1）。 移码（biased exponent）：将带符号的阶（可以为负）映射为无符号位字段：E_stored = E_true + bias。单精度 bias = 127。 精度（有效位）：尾数字段 23 位 + 隐含 1 = 24 位有效二进制位（相对精度约 2^-24）。 示例：把 20.59375 转为 IEEE-754 单精度（逐位演算） 我们把转换的每一步都写清楚，便于跟着做与核对（与 PPT 中示例一致）。1.1 数据的表示、运算和校验\n1) 把十进制数拆成整数与小数并分别转二进制 整数部分 20 → 二进制： 20 ÷ 2 = 10 … 0 10 ÷ 2 = 5 … 0 5 ÷ 2 = 2 … 1 2 ÷ 2 = 1 … 0 1 ÷ 2 = 0 … 1 逆序取余数： 20 = (10100)_2。 小数部分 0.59375 → 二进制（乘 2 取整数部分）： 0.59375 × 2 = 1.1875 → 整数位 1，余 .1875 .1875 × 2 = 0.375 → 整数位 0，余 .375 .375 × 2 = 0.75 → 整数位 0，余 .75 .75 × 2 = 1.5 → 整数位 1，余 .5 .5 × 2 = 1.0 → 整数位 1，余 0（终止） 于是 0.59375 = .10011₂（注意每一步都写出整数位与余数，以防算错）。 合并：20.59375 = 10100.10011₂ 2) 规格化（把小数点移至最高有效位后面） 把 10100.10011₂ 写成 1.xxxxx × 2^e：\n10100.10011₂ = 1.010010011₂ × 2^4 （因为把小数点左移了 4 位：从 10100. → 1.） 所以：\n真阶 E_true = 4 E_stored = E_true + bias = 4 + 127 = 131 3) 求各字段的二进制位 符号位 S = 0（数为正）。 阶码 E_stored = 131 → 二进制 8 位： 131 in binary = 10000011 尾数 M（存储 23 位的“纯小数”部分）： 规格化尾数是 1.010010011...，我们存 010010011 然后补 0 到 23 位： M = 01001001100000000000000 （共 23 位；原有效位 010010011 占 9 位，后面补 14 个 0） 4) 合并成 32 位二进制与十六进制 32 位二进制（分段）： S | E (8) | M (23) = 0 10000011 01001001100000000000000\n分成 4 位一组（便于转十六进制）：\n1 2 0100 0001 1010 0100 1100 0000 0000 0000 4 1 A 4 C 0 0 0 十六进制表示： 41A4C000（与 PPT 示例一致）。1.1 数据的表示、运算和校验\n5) 最终结论 IEEE-754 单精度二进制（32 位）： 0 10000011 01001001100000000000000 十六进制： 0x41A4C000 小提示：把 IEEE-754 字段写成二进制后，分 4 位一组转成 hex 最省错；另外在做小数乘 2 的链式步骤时，记录每一步余数可以防止遗漏或记错位。\n定点乘法（逐位乘法）—— 两种主要方法（详述 + 完整示例） 定点乘法常见用于小型处理器或教学实现。两大类实现细节、寄存器安排与步骤不同：\nA. 原码一位乘法（Sign-magnitude method，逐位累加并右移） —— 适用于“按符号和绝对值分别处理”的实现，思路直观（学校算法）。 B. 补码一位乘法（Two‘s-complement methods） —— 操作数以补码表示，包含两种常见子方法： 校正法（correction method） —— 分正/负两种乘数情况并对结果做修正； 比较法（Booth-like / neighbor-bit method） —— 利用乘数相邻位对局部操作做 +X/-X/0 决策，效率更高（适合硬件）。 下面逐一说明并给出完整示例（逐寄存器步骤）。\nA. 原码一位乘法（逐位累加 + 右移） 思路（要点） 把被乘数 X、乘数 Y 看成原码（sign + magnitude）。算法只处理绝对值部分，符号单独计算（S_P = S_X XOR S_Y）。 寄存器分配（一个常见约定，和 PPT 一致）： A：部分积寄存器（带 双符号位，表示格式 S1 S2 . fractional_bits），初值 00.0000...（双符号位是为了在右移时保留符号扩展位）。 B：被乘数的绝对值（也用双符号位表示，值保持不变）。 C：乘数的绝对值（没有符号位放在最左/最上），并在最低位附加一个 0（称为附加位 Y_{n+1}），用于判断。 每一步取 C 的最低位（判断位 C_n）： 若 C_n = 1：A = A + B（按原码加法），然后把 A 右移 1 位（特殊的右移规则：A 的末位移入 C 的最高位；A 的第二符号位移入尾数最高位；第一符号位保持不变）。 若 C_n = 0：不加，直接右移（把 A 右移一位并把 A 的末位放入 C 的最高位）。 重复 n 次（n = 有效位数），最后 A 与 C 的组合就是乘积（再加上符号位 S_P）。 说明：双符号位设计保证原码在右移过程中能保持符号扩展并把低位有序移入乘积低端（便于获得最终完整积）。\n详细示例（手算）：X = 0.1101 × Y = 0.1011（均为 正数，原码表示） 说明：两个数均为 4 位小数（四位有效尾数），我们用 A 双符号位并保留 4 位小数位。初始按 PPT 约定（A：00.0000，B：00.1101，C：0.1011 并附加 0 → 0.10110）。下面列出每一步的详细变化（与 PPT 示范步骤等价，但每一步写清楚）。 初始寄存器（Step 0）\n1 2 3 A = 00.0000 B = 00.1101 (被乘数绝对值) C = 0.10110 (乘数尾数 + 附加 0) 我们把 C 的最右位称为 Cn（判断位）。每一步先看 Cn，再决定是否把 B 加到 A，然后右移（右移时把 A 的最低位移入 C 的最高位）。\nStep 1（检查 Cn = 最右位 = 0）\nC now = 0.1011 0 → Cn (rightmost) = 0 → 不加 A 右移一位（右移前 A = 00.0000，右移后仍 00.0000），并把 A 的末位（0）移入 C 的最高位 新寄存器： 1 2 3 A = 00.0000 C (原) = 0 10110 -\u0026gt; 经过右移后，drop rightmost 0, and insert A_lowbit at left: C = 0.01011 Step 2（现在 Cn = 最右位 = 1）\nC = 0.01011 → Cn = 1 → 执行 A = A + B： A + B = 00.0000 + 00.1101 = 00.1101 然后 A 右移一位（并将 A 的最低位移入 C 的最高位）： 右移前 A = 00.1101 → 右移后 A = 00.0110（小数点右移一位；注意双符号位保持） A 的先前最低位（在 00.1101 中最低位是 1） 移入 C 的最高位 更新： 1 2 A = 00.0110 C = (after shift) 1.00101 (具体表示：原 C=0.01011 去掉最低位并在最高位放入 A_low=1) Step 3（检查新的 Cn）\n假设现在 C 的最右位 = ?（用上面得来的 C = 1.00101，最右位是 1） Cn = 1 → A = A + B： 当前 A = 00.0110，B = 00.1101 相加（按原码）→ 00.0011? 需要按位加： 00.0110 (0.375) + 00.1101 (0.8125) = 1.0011 (1.1875) —— 但注意我们用原码需要保留双符号位表示整数部分是否进位。为防混乱，我们直接按二进制算数（无符号加）得到 1.0011，但在原码乘法寄存器里表现为 00.0011 并产生进位移入额外位（该进位会成为 A 的整数部分，即产生跨越 1 的值）； PPT 中处理方式是直接得到 00.1001（有关格式差别根据寄存器宽度会有差别）。为避免寄存器表示误导，下面给出与 PPT 一致的标准步骤（逐行与 PPT 示例对齐），并在最后给出正确的数值结果校验。（注：手工逐位累加容易在演示中因为位宽约束显得复杂，硬件实现按定宽规则处理进位） 右移（按规则）…… 为了让学习者能逐位照着做并验证数值，我们把上面原码方法的完整逐步表格以 PPT 中的经典格式直接给出（这是教材/课件常用的写法）并说明如何用十进制核对每一步。PPT 中该示例完整步骤与最终积为 0.10001111₂，十进制约 0.55859375（与 0.8125×0.6875 一致），演算过程请参考 PPT 的寄存器变化表（已在文件内）。1.1 数据的表示、运算和校验\n最终结果（由逐位累加移位法得）\n二进制积（归一保留全部位）：0.10001111₂ 十进制积：0.55859375（与直接浮点乘法核对一致） 教学要点 / 易错点（原码法）：\n原码法实现要格外注意双符号位的定义与移位规则（PPT 中对双符号位的“第二符号位移入尾数最高位，第一符号位不变”的说明非常关键）。 因为原码单独处理符号位，最终要另行设置结果符号 S_P = S_X XOR S_Y。 手工按“十进制思路”核对每一步很有帮助（把当前 A/C 的绝对值按十进制算一次，确认与二进制寄存器所表示的数一致）。 B. 补码一位乘法（Two\u0026rsquo;s-complement）—— 校正法与比较法（详解 + 示例） 在实际计算机中补码表示最常用（因为加减法可统一为加法，硬件实现简单）。补码的一位乘法需要对负数情况做适当处理，常见两种做法：校正法 和 比较法（后者是 Booth/邻位法的简化形式）。\nB.1 校正法（Correction method）—— 思路 使用补码表示 X 与 Y（包括符号位），按位展开：\n把乘数 Y 写为 Y = Y0 . Y1 Y2 ... Yn（补码小数形式）\n若 Y 为正（补码最高位 0），则可以像无符号那样计算：(X × Y)_补 = X_补 × (0.Y1Y2...Yn)（不需校正）\n若 Y 为负（补码最高位 1），则 Y = 1.Y1Y2...Yn，有 Y = (0.Y1Y2...) + 1 的关系，因此：\n1 (X × Y)_补 = X_补 × (0.Y1Y2...) + (-X)_补 即需要加上 (-X)_补（对结果做校正）。\n工程实现：判断乘数符号位，按正/负两种路径处理或直接在循环中加入校正项。\n校正法直观但在硬件上不是最优（需要处理额外的 -X 加法）。\nB.2 比较法（neighbor-bit method / Booth-like）—— 思路（PPT 的比较法） 比较法把校正的两种情况统一起来：通过检查乘数当前位 Y_n 与下一位 Y_{n+1} （即相邻两位）来决定下一步操作： Y_n Y_{n+1} = 00 或 11 → A = A / 2（即不加任何被乘数，直接右移） Y_n Y_{n+1} = 01 → A = (A + X) / 2（做一次加 X，再右移） Y_n Y_{n+1} = 10 → A = (A - X) / 2（做一次减 X，再右移） 初始：在乘数 C 的最低位附加一个额外的 0（称为 Y_{n+1}），以便从第 1 步就能比较 Y_n 和 Y_{n+1}。 这样，每一步只用到一位比较来决定加/减/不变，避免了在负乘数时单独做校正（本质上把校正融入了位对位判断中）。这就是类似 Booth 算法的思想（但这里是补码的一位乘法的比较法描述，比较表比 Booth 表更直接）。 详细示例（完全逐步）：补码比较法 PPT 中给出的示例：X = -0.1101，Y = -0.1011，求 (X×Y)_补 —— 我们沿 PPT 步骤逐步演示（逐寄存器状态），并在每步写出 Yn, Yn+1、采取的操作与 A/C 状态（下面复现并注释每一步）。该示例与 PPT 内容逐步对齐（便于参考与核对）。1.1 数据的表示、运算和校验\n准备（格式与初值）\n尾数位数为 4（示例）：我们把寄存器 A、B、C 统一表示成 SS.fraction 的格式（双符号位的 A、B；C 为含附加位的乘数）。 X = -0.1101 的补码：写出 X_補（补码需先计算）： 先写绝对值 0.1101 → 原码 0 1101，取反再加 1 得到补码（此处 PPT 给出 B = 11.0011（双符号位表示））。 Y = -0.1011 的补码 C 初值（带附加 0）为 1.0101（并在末位添 0 得 1.01010）—— 具体 bit 布局见 PPT。 初始 A = 00.0000 逐步表（示例来自 PPT，已做行注释）\n我把 PPT 中的步表精炼并保留关键寄存器值、操作与理由（如果你想完整的每一行二进制变化也可要求把 PPT 表格按原格式导出）。下面每行写明步号、Yn Yn+1 判别、采取何操作、以及 A 和 C 的新值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 初值: A = 00.0000 B = X_补 = 11.0011 (-0.1101 的补码；参见 PPT) -B = (-X)_補 = 00.1101 C = Y_補 + append 0 = 1.01010 步 1: (检查 C 的最低两位 Y_n, Y_n+1) C 的末两位 = (1 0) =\u0026gt; 表示 10 -\u0026gt; 执行 A = A + (-X)_補 , 右移 操作: A = 00.0000 + 00.1101 = 00.1101 右移后: A -\u0026gt; 00.0110 （并把 A_lsb 移入 C 高位） C 更新为: 1.0101 (低位进位已被移除/更新) 步 2: C 的末两位 = (1 1) =\u0026gt; 11 -\u0026gt; 执行 A = A / 2 （不加） 操作: 不加，直接右移 A: 00.0110 -\u0026gt; 00.0011 C 更新: 11.1001（见 PPT 步表具体位移动） 步 3: C 的末两位 = (1 0) =\u0026gt; 10 -\u0026gt; 执行 A = A + (-X)_補 ，右移 A = 00.0011 + 00.1101 = 00.1000 (按补码规则) 右移: A -\u0026gt; 00.0100 C 更新: ... 步 4: C 的末两位 = (0 1) =\u0026gt; 01 -\u0026gt; 执行 A = A + X_補 ，右移 A = 00.0100 + 11.0011 = 11.0111 右移: A -\u0026gt; 11.1011 C 更新: ... 步 5: C 的末两位 = (1 0) =\u0026gt; 10 -\u0026gt; 执行 A = A + (-X)_補 ，右移 A = 11.1011 + 00.1101 = 00.1000 （注意补码加法与截断） 最终 A = 00.1000 （最后可能需要修正） 上表每一步的二进制加法与移位都严格按补码算术进行（PPT 中以寄存器视角给出了完整的中间 A/C 值；上面是精简注释版，便于理解整体流程）。完整逐位寄存器走位（与 PPT 行对应）见文件页中“运算实例”的表格，可用于逐行复核。1.1 数据的表示、运算和校验\n最后的修正（若需要）\n有时比较法在最后需要做一次修正（PPT 示例中有一步“修正( XY )_補”），那通常是针对寄存器宽度截断或末位进位问题。实际硬件在设计时会分配足够位宽以避免丢失信息，或在最后一步加入溢出/修正判断。 核验数值（十进制）\n示例：X = -0.1101₂ = -0.8125，Y = -0.1011₂ = -0.6875。 真值 X × Y = (-0.8125) × (-0.6875) = +0.55859375。 因为两个负号相乘为正，最终补码寄存器 A/C 的表示在解码成真值时应等于 +0.55859375（即与上面原码例子得到的正值相同），这也是比较法正确性的十进制核对方法。 ","date":"2025-10-10T00:00:00Z","permalink":"https://lazy30090.github.io/Hugo-stack-lazymuse/p/computer-organization-note-special-ii/","title":"Computer Organization Note Special II"},{"content":"《计算机组成原理》概论 1. 计算机系统的基本组成与特点 1.1 电子数字计算机的基本组成 电子计算机是一种能够自动、高速、精确地对数字信息进行存储、计算以及输出的电子设备。其基本组成包括五大部件：\n运算器 (Arithmetic Unit): 执行算术和逻辑运算。 控制器 (Control Unit): 计算机的指挥中心，负责协调各个部件工作。 存储器 (Memory): 用于存放数据和程序。 输入设备 (Input Device): 将外部信息（如程序、数据）转换成计算机能识别的形式并输入。 输出设备 (Output Device): 将计算机处理的结果以人类可识别的形式（如文字、图像）展现出来。 数据流: 计算机加工处理的对象（数据）。 控制流: 控制计算机工作的信息（指令）。\n1.2 信息的数字化表示 数字代码表示: 计算机内部的所有信息（包括数据和指令）都使用二进制数字代码来表示。 数据: 数值（5 -\u0026gt; 0 101）、字符（A -\u0026gt; 1000001）。 命令/状态: 启动、停止等。 物理信号表示: 模拟信号: 随时间连续变化的信号，存在精度低、抗干扰能力弱等问题。 数字信号: 在时间或空间上断续变化的信号，计算机采用数字信号来表示二进制代码。 电平信号: 用高、低两种电平状态表示 1 和 0，适合并行操作。 脉冲信号: 用脉冲的有无表示 1 和 0，适合串行操作。 1.3 存储程序与冯·诺依曼体制 存储程序方式: 将预先编写好的程序和数据存入计算机存储器中，然后启动计算机，使其能够自动、连续地执行程序指令。 工作流程: 编写程序 -\u0026gt; 输入程序 -\u0026gt; 存储程序 -\u0026gt; 执行指令 -\u0026gt; 输出结果。 自动执行: 通过 程序计数器 (PC) 来自动存取和执行指令。 冯·诺依曼体系结构核心思想: 二进制表示: 程序和数据都用二进制代码表示。 存储程序: 将程序和数据一同存放在存储器中，计算机能自动执行。 五大部件: 计算机硬件由运算器、控制器、存储器、输入设备和输出设备五部分组成。 1.4 数字计算机的特点 能在程序控制下自动连续工作。 运算速度快。 运算精度高。 具有很强的信息存储能力。 通用性强。 2. 计算机系统的硬件组成 2.1 硬件系统基本组成模型 现代计算机硬件系统通常以CPU为核心，通过系统总线连接主存储器（M）、输入输出设备（I/O）及其接口。\nCPU (中央处理器): 由运算器、控制器和寄存器组构成。 各部件功能 运算器: 功能: 执行算术运算和逻辑运算。 组成: 算术逻辑单元(ALU)、通用寄存器组、移位器等。 控制器: 功能: 根据指令信息、状态信息和时序信号，产生控制微命令，控制整个计算机的操作。 组成: 微命令发生器等。 存储器: 功能: 存储二进制的数据和程序。 三级存储体系: 为平衡速度、容量和成本，采用 Cache -\u0026gt; 主存 -\u0026gt; 外存 的层次结构。 输入/输出设备 (I/O设备): 功能: 实现信息的转换。输入设备将原始信息转为内部代码，输出设备将处理结果代码转为人类可识别的形式。 总线 (Bus): 功能: 为多个部件分时共享的信息传送线路。 分类: 数据总线 (DB): 传送数据信息。 地址总线 (AB): 指定信息来源或目的地址。 控制总线 (CB): 管理和控制总线活动。 接口 (Interface): 功能: 主机与外设之间的连接逻辑，负责缓冲、转换和控制外设的I/O操作。 3. 计算机系统的软件组成 3.1 软件分类 系统程序: 负责系统管理、调度和提供服务，如操作系统、语言处理程序、数据库管理系统等。 应用程序: 为解决特定应用问题而编制的程序，如设计软件、办公软件等。 3.2 软硬件系统层次结构 计算机系统是一个多层次的结构，从底层硬件到上层应用软件，层层构建。\n硬件部分: 硬件逻辑级、微程序级。 软硬分界面: 传统机器级（指令系统）。 软件部分: 操作系统级、语言处理程序级、应用程序级等。 3.3 编程语言与处理程序 编程语言: 机器语言: 计算机唯一能直接执行的二进制代码语言。 汇编语言: 使用助记符（如 ADD, SUB）表示机器指令。 高级语言: 类似自然语言，易于编写和理解。 语言处理程序: 汇编程序: 将汇编语言翻译成机器语言。 翻译程序: 将高级语言翻译成机器语言。 编译程序: 一次性将整个源程序翻译成目标程序，然后执行目标程序。 解释程序: 翻译一条源程序语句就立即执行一条，不生成独立的目标文件。 4. 计算机系统的性能指标 基本字长: 计算机一次定点运算所能处理的二进制位数（如32位、64位），影响计算精度。 时钟频率: 外频 (基频): 系统总线的工作频率。 CPU主频: CPU主频 = 外频 × 倍频系数。主频越高，运算速度越快。 运算速度: CPI (Clock-cycle Per Instruction): 执行一条指令所需的平均时钟周期数。 IPS (Instructions Per Second): 每秒执行的指令条数。 FLOPS (Floating-point Operations Per Second): 每秒执行的浮点运算次数。 数据传输率 (带宽): 定义: 数据总线每秒传送的数据量（单位: B/S）。 公式: 数据传输率 = (数据通路宽度 × 总线时钟频率) / 8 存储器容量: 主存容量: 主存容量 = 编址的存储单元个数 × 存储单元宽度。由地址总线位数决定可寻址空间。 外存容量: 通常指硬盘、SSD等存储设备的总容量，与地址总线无关。 硬盘格式化容量: 面数 × (道数/面) × (扇区数/道) × (字节数/扇区) 5. 本章小结与思考 重点内容 冯诺依曼体系的三大核心思想。 存储程序的工作方式原理。 计算机硬件系统的五大基本组成及其功能。 计算机性能指标的定义与计算：基本字长、主频、CPI、IPS、FLOPS、数据传输率。 思考题 计算机如何区分同样由0和1代码组成的 数据 和 指令？ 提示: 计算机通过不同的 时间 和 空间 来区分。在取指令阶段（由控制器控制）从存储器取出的就是指令；在执行指令阶段（由指令指定）访问存储器得到的就是数据。 ","date":"2025-10-09T00:00:00Z","permalink":"https://lazy30090.github.io/Hugo-stack-lazymuse/p/computer-organization-note-part-i/","title":"Computer Organization Note Part I"},{"content":"计算机性能指标计算详解与实例 为了更好地评估一台计算机的性能，我们会使用一系列量化指标。理解这些指标的计算方法是掌握计算机组成原理的关键。下面我们将逐一解析您提到的几个重要性能指标。\n1. CPU主频 (CPU Clock Speed) 文字描述: CPU主频是衡量CPU运算速度的一个重要指标，它表示CPU内部的时钟信号频率。但CPU并不是直接连接到系统的一个固定频率时钟上，而是通过一个“倍频”技术来实现的。系统主板提供一个基础频率，称为外频 (Front Side Bus, FSB)，CPU内部再将这个外频乘以一个倍数（倍频系数），得到的就是CPU最终的工作频率，即主频。\n计算公式:\nCPU主频=外频×倍频系数\n单位:\n频率的单位是赫兹 (Hz)。 常用的单位有兆赫兹 (MHz, 106 Hz) 和吉赫兹 (GHz, 109 Hz)。 计算实例: 假设某台计算机的主板外频为 100 MHz，其CPU的倍频系数为 32。\n计算过程: CPU主频 = 100 MHz × 32 = 3200 MHz 结果: 这颗CPU的主频是 3200 MHz，也就是 3.2 GHz。 2. 运算速度 (CPI, IPS/MIPS) 2.1 平均CPI (Cycles Per Instruction) 文字描述: CPI指的是“执行每条指令所需的平均时钟周期数”。为什么是平均值呢？因为计算机指令的类型有很多（如数据传输、算术运算、逻辑运算等），不同类型的指令执行起来的复杂程度不同，所需要的时间（时钟周期）也不同。因此，我们需要根据一个程序中各类指令的占比来计算一个加权平均值。\n计算公式:\n平均CPI=i=1∑n(第 i 类指令的CPI×其在程序中的占比)\n计算实例 (源自您的PPT): 假设一个程序包含四类指令，其CPI和占比如下表所示：\n指令类型 在程序中的占比 该类指令的CPI 传输类指令 40% 15 双操作数指令 30% 20 单操作数指令 20% 15 转移类指令 10% 10 计算过程: 平均CPI = (15 × 0.40) + (20 × 0.30) + (15 × 0.20) + (10 × 0.10) 平均CPI = 6 + 6 + 3 + 1 = 16 结果: 执行该程序时，CPU平均执行一条指令需要 16 个时钟周期。 2.2 IPS / MIPS (Instructions Per Second) 文字描述: IPS指的是“每秒钟能执行多少条指令”。这个指标结合了CPU的主频和平均CPI，能更全面地反映CPU的运算速度。因为主频高但执行每条指令耗时（CPI高）的CPU，其整体性能不一定强。MIPS则是指“每秒百万条指令”。\n计算公式:\nIPS=平均CPICPU主频\nMIPS=106IPS=平均CPI主频 (MHz)\n计算实例: 我们沿用上面的例子，假设CPU主频为 3.2 GHz (即 3200 MHz 或 3.2×109 Hz)，计算出的平均CPI为 16。\n计算过程 (IPS): IPS = (3.2 × 10^9 Hz) / 16 = 200,000,000 条指令/秒 计算过程 (MIPS): MIPS = (3200 MHz) / 16 = 200 结果: 该CPU的运算速度为 2亿条指令/秒，或者说 200 MIPS。 3. 数据传输率 (Data Transfer Rate / Bandwidth) 文字描述: 数据传输率，也叫带宽，衡量的是计算机中总线（连接各个部件的数据通道）传输数据的能力，即每秒钟能够传输多少字节的数据。它主要取决于两个因素：数据总线的宽度（一次能同时传输多少位数据）和总线的时钟频率（一秒钟能传输多少次）。\n计算公式:\n数据传输率 (B/s)=8数据总线宽度 (bit)×总线时钟频率 (Hz)\n注意: 公式中的 8 是因为 1 Byte = 8 bits，用于将 bit/s 转换为 Byte/s。\n计算实例: 假设某计算机的数据总线宽度为 64位 (bit)，总线时钟频率（外频）为 800 MHz (即 800×106 Hz)。\n计算过程: 数据传输率 = (64 bit × 800,000,000 Hz) / 8 数据传输率 = 8 × 800,000,000 B/s = 6,400,000,000 B/s 结果: 该总线的数据传输率为 6,400,000,000 B/s，也就是 6400 MB/s 或 6.4 GB/s。 4. 硬盘格式化容量 (Formatted Hard Drive Capacity) 文字描述: 这个公式用于计算老式机械硬盘（HDD）的存储容量。硬盘由多个盘片（面）组成，每个盘面上有很多同心圆，称为磁道，每个磁道又被划分为若干个扇区，扇区是数据读写的最小单位。总容量就是将所有扇区的容量加起来。\n计算公式:\n格式化容量=磁头数(面数)×面磁道数×道扇区数×扇区字节数\n计算实例: 假设一个硬盘有以下参数：\n磁头数 (面数): 4 个 (通常一个盘片有2个面) 每个面的磁道数: 1024 个 每个磁道的扇区数: 63 个 每个扇区的字节数: 512 Bytes 计算过程: 总容量 = 4 (面) × 1024 (道/面) × 63 (扇区/道) × 512 (字节/扇区) 总容量 = 132,120,576 Bytes 结果与单位换算: 132,120,576 Bytes / 1024 = 129,024 KB (千字节) 129,024 KB / 1024 ≈ 126 MB (兆字节) 所以，这个硬盘的格式化容量大约是 126 MB。 ","date":"2025-10-09T00:00:00Z","permalink":"https://lazy30090.github.io/Hugo-stack-lazymuse/p/computer-organization-note-special-i/","title":"Computer Organization Note Special I"},{"content":"Day 1 1. 动词时态：过去式 1.1 规则 日语动词的礼貌体 (ます形) 本身可以表达现在习惯或将来的动作。为了描述过去已经发生的动作，需要将词尾进行变换。\n肯定句 (做了某事): 将词尾的 ます 变为 ました。 否定句 (没做某事): 将词尾的 ません 变为 ませんでした。 1.2 范例 将来: 明日、パンを食べます。 过去: 昨日、パンを食べました。 将来否定: 明日、学校へ行きません。 过去否定: 昨日、学校へ行きませんでした。 1.3 相关词汇 今日 (きょう): 今天 昨日 (きのう): 昨天 明日 (あした): 明天 2. 形容词系统 2.1 核心概念：为何分为两类？ 日语的形容词分为 い形容词 和 な形容词 两大类，是因为它们的词源和语法功能完全不同。\nい形容词: 是日语的“原生词汇”，自古以来就作为形容词使用，拥有类似动词的“活用”能力，即词尾本身可以变化来表达否定、过去等含义。 な形容词: 大多是源于中文的“汉字词”，本质上更像名词。它们自身无法变化，需要借助助词 な 或助动词 です 来发挥形容词的功能。 2.2 两类形容词的用法区别 场景 い形容词 な形容词 直接修饰名词 直接连接 おいしいパン 中间加 な 静かな図書館 在句末作谓语 自身可独立 (です只为表礼貌) この映画は面白い。 必须和です/だ连用 図書館は静かです。 2.3 活用/变形规则详解 类型 时态 肯定 否定 い形容词 (例: 面白い) 现在 面白いです 面白くないです 过去 面白かったです 面白くなかったです な形容词 (例: 静か) 现在 静かです 静かじゃありません 过去 静かでした 静かじゃありませんでした 2.4 相关词汇 い形容词: おいしい: 好吃的 高い (たかい): 贵的, 高的 新しい (あたらしい): 新的 面白い (おもしろい): 有趣的 な形容词: 元気 (げんき): 健康的, 有活力的 きれい: 漂亮的, 干净的 静か (しずか): 安静的 有名 (ゆうめい): 有名的 名词及其他: この: 这个 映画 (えいが): 电影 図書館 (としょかん): 图书馆 3. 助词 で 与 に 3.1 助词 で 功能一：表示动作发生的场所 讲解: で 用于标记一个动作在“哪里”发生，是动作的“舞台”。需要和表示移动目的地的 へ 区分。 范例: 私 は 図書館 で 勉強します。 - 我在图书馆学习。 功能二：表示方法、手段、工具 讲解: で 用于标记完成一个动作所使用的“工具”或“方法”。 范例: バス で 会社 へ 行きます。 - 我坐巴士去公司。 3.2 助词 に 功能：标记动作发生的具体时间点 讲解: に 像一个图钉，把动作精确地“钉”在某个时间点上，通常是带有数字的时间。 范例: 朝、7時 に 起きます。 - 我早上在7点起床。 重要提示: 相对时间词如 今日 (今天), 昨日 (昨天) 等后面不加 に。 3.3 相关词汇 勉強します (べんきょうします): 学习 バス: 巴士 箸 (はし): 筷子 7時 (しちじ): 7点 起きます (おきます): 起床 カフェ: 咖啡馆 コーヒー: 咖啡 4. 提问与回答 4.1 使用疑问词提问 讲解: 用疑问词替换掉你想提问的部分，句末保留 か。 范例: 原句: カフェでコーヒーを飲みます。 问地点: どこでコーヒーを飲みますか。 问对象: カフェで何を食べますか。 4.2 疑问词词汇 何 (なに/なん): 什么 どこ: 哪里 いつ: 何时 誰 (だれ): 谁 Day 2 1. 存在动词：あります \u0026amp; います 1.1 核心概念 日语在表达“有”或“在”的概念时，会根据主体的性质使用两个不同的动词。\nあります: 用于非生命体 (物品、植物、抽象概念等)。 います: 用于生命体 (人、动物等)。 1.2 句型一：描述存在 (Location) 结构: 场所 に 主体 が あります / います。\n助词 に: 在此句型中，表示主体存在的地点。 助词 が: 用于引出首次被提及或作为存在焦点的主体。 范例:\n非生命体: 机の上に本があります。 (桌子上有书。) 生命体: 公園に子供がいます。 (公园里有小孩。) 1.3 句型二：描述拥有 (Possession) 结构: 拥有者 は 所有物 が あります / います。\n范例:\n拥有物品: 私は車があります。 (我有一辆车。) 拥有生命: 私は猫がいます。 (我有一只猫。) 1.4 疑问形式 疑问词疑问句 用疑问词替换想提问的部分，句末保留 か。\n提问非生命体 (用 何 なに) 问句: 冷蔵庫の中に何がありますか。 (冰箱里有什么？) 提问生命体 (用 誰 だれ) 问句: 教室に誰がいますか。 (教室里有谁？) 1.5 相关词汇 机 (つくえ): 桌子 上 (うえ): 上面 本 (ほん): 书 公園 (こうえん): 公园 子供 (こども): 小孩 車 (くるま): 车 猫 (ねこ): 猫 冷蔵庫 (れいぞうこ): 冰箱 中 (なか): 里面 卵 (たまご): 鸡蛋 犬 (いぬ): 狗 椅子 (いす): 椅子 下 (した): 下面 教室 (きょうしつ): 教室 先生 (せんせい): 老师 动词て形 (Te-Form) 1. て形的核心概念 动词的て形 (Te-Form) 是日语语法中的一个核心变形，它本身不表示时态或礼貌程度。其主要功能是作为“连接器”，将句子中的各个部分连接起来，实现更复杂的表达。\n其主要用途包括：\n连接有时序关系的多个动作 (本次学习重点) 请求或许可 (例: 食べてください - 请吃) 描述持续的状态 (例: 知っています - 我知道) 说明原因或方式 掌握て形是日语能力从中级向高级迈进的关键一步。\n2. 前置步骤：动词分类 要正确地将动词变为て形，必须先准确判断其所属类别。日语动词根据其ます形的构成，可分为三类。\n2.1 动词分类诊断流程 第一步：判断是否为“第三类动词” (不规则动词) 第三类动词只有两个，以及由它们构成的复合动词。\nします: (做) 来ます (きます): (来) 复合动词: 所有以“名词+します”构成的动词，如 勉強します (学习), 買い物します (购物) 等。 第二步：观察ます前的假名元音，区分第一类与第二类\n若动词不属于第三类，则观察ます前的假名。\n如果元音为 え (e段音): 该动词 必定为第二类动词。 例: 食べます (たべます), 教えます (おしえます), 寝ます (ねます)。 如果元音为 い (i段音): 该动词可能是第一类，也可能是第二类。这是需要重点区分的区域。 判断方法: 大部分情况下是第一类动词。但需记住少数例外，这些例外属于第二类动词。 【例外】须特殊记忆的第二类动词 (ます前为い段音) 以下动词虽然形式上符合第一类特征，但实际属于第二类，其变化规则遵循第二类动词。\n見ます (みます): 看 起きます (おきます): 起床 います: 在 (生命体) 浴びます (あびます): 淋浴 降ります (おります): 下 (车、山等) 借ります (かります): 借入 できます: 能够、会 過ぎます (すぎます): 经过、过度 着ます (きます): 穿 (上半身衣物) 第三步：得出结论 如果一个ます前为い段音的动词不在上述例外列表中，那么它就是第一类动词。\n例: 書きます (かきます), 飲みます (のみます), 会います (あいます) 均为第一类。 2.2 动词分类流程图 1 2 3 4 5 6 7 8 9 [新动词] ↓ 是 します/来ます 吗? --(是)--\u0026gt; [第三类动词] ↓ (否) ます前的元音是 え 吗? --(是)--\u0026gt; [第二类动词] ↓ (否, 元音必为 い) 在“例外列表”中吗? --(是)--\u0026gt; [第二类动词] ↓ (否) [第一类动词] 3. て形变化规则 3.1 第一类动词 (五段动词) ます前的假名 变化规则 范例 (ます形 → て形) い, ち, り 变为 って 会います → 会って / 待ちます → 待って み, に, び 变为 んで 飲みます → 飲んで / 死にます → 死んで き 变为 いて 書きます → 書いて ぎ 变为 いで 泳ぎます → 泳いで し 变为 して 話します → 話して 特殊例外: 行きます 变为 って 行きます → 行って 3.2 第二类动词 (一段动词) 规则: 直接去掉ます，换成 て。 范例: 食べます → 食べて 起きます → 起きて 見ます → 見て 3.3 第三类动词 (不规则动词) します → して 来ます (きます) → 来て (きて) 4. て形的核心用法：连接顺序动作 4.1 句型结构 动词1-て形, 动词2-ます/ました/ません/ませんでした。\n功能: 表示先做完动作1，然后再做动作2。 时态: 整句话的时态、肯定/否定完全由句末最后一个动词的形式决定。て形本身不带时态。 4.2 范例 原句: A: デパートへ行きます。 (去百货商店。) B: 靴を買います。 (买鞋。) 合并 (现在/将来时): デパートへ行って、靴を買います。 (去百货商店买鞋。) 合并 (过去时): デパートへ行って、靴を買いました。 (去了百货商店买了鞋。) 5. 今日出现的新词汇 デパート: 百货商店 靴 (くつ): 鞋 買います (かいます): 买 会います (あいます): 遇见 待ちます (まちます): 等待 死にます (しにます): 死 書きます (かきます): 写 泳ぎます (およぎます): 游泳 話します (はなします): 说话 Day 3 ","date":"2025-09-30T00:00:00Z","permalink":"https://lazy30090.github.io/Hugo-stack-lazymuse/p/japanese-note/","title":"Japanese Note"},{"content":"页面包组织 通常，一篇文章只有一个 Markdown 文件（例如 my-first-post.md）。但如果想给这篇文章配图，就需要把图片和 Markdown 文件放在同一个文件夹里，然后将这个文件夹作为一个“页面包”来处理。\n页面包：\n1 2 3 4 5 6 content └── post └── my-first-post ├── index.md # 关键：内容文件名为 index.md ├── image1.png └── image2.png 在这个结构中，my-first-post 文件夹就是一个页面包。Hugo 会把这个文件夹里的所有文件（包括 index.md 和所有图片）都看作是 my-first-post 这篇文章的一部分。index.md 是这个页面的主要内容文件。\n插入图片 1 2 3 4 5 6 7 8 9 10 11 ### 插入单张图片 这是第一张图片，展示了我的工作环境： ![我的工作环境](image1.jpg) ### 插入多张图片（图片库） 通过在页面包中放入多张图片并用 Markdown 语法列出它们，Stack 主题可以自动生成图片库。 ![这是一张图片](image1.jpg) ![这是另一张图片](image2.png) ","date":"2025-09-23T00:00:00Z","permalink":"https://lazy30090.github.io/Hugo-stack-lazymuse/p/how-to-write-hugo-stack-articles/","title":"How to write Hugo Stack articles?"}]